<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>php on xiaok&#39;s blog</title>
    <link>https://wangtingkui.com/tags/php/</link>
    <description>Recent content in php on xiaok&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 19 Jul 2020 11:24:13 +0800</lastBuildDate><atom:link href="https://wangtingkui.com/tags/php/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Phpunit解决测试依赖</title>
      <link>https://wangtingkui.com/posts/php/phpunit%E8%A7%A3%E5%86%B3%E6%B5%8B%E8%AF%95%E4%BE%9D%E8%B5%96/</link>
      <pubDate>Sun, 19 Jul 2020 11:24:13 +0800</pubDate>
      
      <guid>https://wangtingkui.com/posts/php/phpunit%E8%A7%A3%E5%86%B3%E6%B5%8B%E8%AF%95%E4%BE%9D%E8%B5%96/</guid>
      <description>介绍 在书写单测代码的过程中，我们要测试的代码段往往会依赖其他的模块，如果是简单的模块还好，但是如果遇到复杂的模块（比如依赖各种其他的组件，db、redis、api调用等等），被依赖模块的稳定程度会影响我们的单测。而且被依赖模块返回的不确定性也使得我们无法编写单测代码
为了解决这类型问题，我们可以使用测试替身，本质其实就是对数据进行mock
在 phpunit 中，使用测试替身有两种方式，一种是Stubs（桩件），另外一种是Mock Object（仿件对象）。这两个概念有啥区别呢？其实是测试重点不同：
 桩件注重的是可以对我们被依赖的模块进行返回值的设置，让单测可以按照我们期望的路径运行，往往还需要在我们的单测代码中书写各种断言 仿件对象注重的是被依赖模块的调用过程，比如被依赖对象中的A方法一定会被调用一次，使用仿件对象的单测，往往不需要在我们的单测代码中显示出现断言  使用 关于测试替身的详细使用，可以直接参考官方文档</description>
    </item>
    
    <item>
      <title>php 中的匿名函数和 Closure</title>
      <link>https://wangtingkui.com/posts/php/closure/</link>
      <pubDate>Wed, 24 Jun 2020 11:53:13 +0800</pubDate>
      
      <guid>https://wangtingkui.com/posts/php/closure/</guid>
      <description>php 中匿名函数也叫做闭包函数，允许我们创建一个没有名称的函数，经常用作回调函数
php 中的匿名函数是基于 Closure 这个类来实现的
基本使用 通常会将匿名函数用作回调函数
array_filter([1,2,3], function ($item) { return $item % 2 == 0; }); // 也可以赋值给变量，供后续使用 $func = function () { echo &amp;#34;called&amp;#34; . PHP_EOL; } $func(); 使用父作用域变量 接触过其他有闭包特性语言的同学，一定会知道闭包的一大特点是可以使用父作用域的变量，php中的必报同样可以，但是使用上稍微有些区别
php 中使用父作用域的变量，需要使用 use 关键字传递
$a = 1; $func = function () use ($a) { echo $a; }; $func(); // 1 $a = 2; $func(); // 1 可能有的同学会感到奇怪，为什么上面两次调用输出的都是1，这是因为在 php 中，传值方式默认使用的都是值传递，如果需要在匿名函数中保有对父作用域变量的引用，需要使用引用传值的方式
$a = 1; $func = function () use (&amp;amp;$a) { echo $a; }; $func(); // 1 $a = 2; $func(); // 2 特别需要注意的是</description>
    </item>
    
    <item>
      <title>php多版本管理</title>
      <link>https://wangtingkui.com/posts/php/php-multi-version/</link>
      <pubDate>Tue, 14 Jan 2020 19:11:11 +0800</pubDate>
      
      <guid>https://wangtingkui.com/posts/php/php-multi-version/</guid>
      <description>本篇文章是写一下我怎么进行php的多版本管理，利用的是phpbrew这个工具
 phpbrew github 地址  phpbrew安装过程 第一步 首先需要下载 phpbrew 的二进制文件
# 下载执行文件 curl -L -O https://github.com/phpbrew/phpbrew/releases/latest/download/phpbrew.phar # 添加执行权限 chmod +x phpbrew.phar # Move the file to some directory within your $PATH sudo mv phpbrew.phar /usr/local/bin/phpbrew 第二步 安装好二进制文件之后，phpbrew还需要一点简单的配置才能使用
# 初始化phpbrew shell脚本 phpbrew init # 在shell配置文件（~/.bashrc 或者 ~/.zshrc）中添加 echo &amp;quot;[[ -e ~/.phpbrew/bashrc ]] &amp;amp;&amp;amp; source ~/.phpbrew/bashrc&amp;quot; &amp;gt;&amp;gt; ~/.zshrc # 重新加载shell配置文件 source ~/.zshrc 第三步 设置用于查找库文件的默认前缀，可选值有 macports，homebrew，debian，ubuntu 或是自定义路径。
对于使用homebrew的用户，可以设置phpbrew lookup-prefix homebrew
phpbrew命令简单使用 # 查看phpbrew版本 phpbrew --version # 查看可以安装的版本 phpbrew know # 列出本地已经安装的版本 phpbrew list # 临时切换版本 phpbrew use 7.</description>
    </item>
    
  </channel>
</rss>
