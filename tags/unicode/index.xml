<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>unicode on xiaok&#39;s blog</title>
    <link>https://wangtingkui.com/tags/unicode/</link>
    <description>Recent content in unicode on xiaok&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 22 Sep 2019 15:45:32 +0800</lastBuildDate><atom:link href="https://wangtingkui.com/tags/unicode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>详解字符编码</title>
      <link>https://wangtingkui.com/posts/base/unicode/</link>
      <pubDate>Sun, 22 Sep 2019 15:45:32 +0800</pubDate>
      
      <guid>https://wangtingkui.com/posts/base/unicode/</guid>
      <description>作为一名coder，日常的开发工作中不可避免的会接触一些字符编码相关的东西，之前只是模模糊糊的了解一点，没有明确的，系统性的认知。一个最典型的例子就是当我们的代码遇到了乱码，这时候其他人总会告诉我们要使用utf-8编码就可以解决问题，但这背后蕴含的原理，却一直没有探索过，所以就查了一些资料，将查到的资料提炼汇总，有了这篇文章
字符编码的发展历程 我们知道，所有的数据在计算机中都是用二进制串来表示的，那么人类世界的语言符号，想要在计算机中表示，就必须有对应的转换规则，这就是字符编码
ASCII 时期 上世纪60年代，美国制定了一套字符编码，它使用一个字节来对英语字符和二进制串进行映射，这就是ASCII码。
ASCII一共规定了128个字符，其中包含32个控制字符，由于ASCII只有128个字符，所以只占用了一个字节的7位，所以规定最前面的1位统一为0
传统字符编码时期 由于不是所有国家的语言体系都是英文，比如中国使用的汉字，字符数量就远远超过了一个字符所能容纳的极限，所有随着计算机的普及，各个国家都提出了自己的字符编码方案，基本的策略就是使用更多的字节空间，兼容ASCII，然后用剩下的空间来编码其他的字符。比如中国的GB2312、BIG5等，但是这就导致了一个问题，各个国家都只是兼容了ASCII，然后编码了本国语言，对其他语言是不支持的，所以导致当时的计算机只能处理双语言环境，不支持多语言环境。
假如遇到要在一个文本中同时出现中文、英文、阿拉伯文的时候，就无法进行编码处理了。
unicode 时期 为了解决传统编码方式带来的问题，unicode出现了，下面就让我们详细看下unicode是如何解决上面的这些问题的
现代编码模型 在探讨unicode是个什么东西之前，我们先来了解一下现代编码模型，因为要完美解决上面提到的编码问题，以及保证这套字符编码的可扩展性（因为到现在为止，还不断有更多的字符在加入到我们的语言体系之中），已经不能只是用简单规定几个字节，然后将字符和编码一一对应来处理了。
现代编码模型将字符编码从底向上分为了几个层次：
 抽象字符表（Abstract Character Repertoire）   就是这个编码系统所包含的所有抽象字符的集合，比如ASCII编码里面就有128个抽象字符。抽象字符表可以是封闭的，比如ASCII，不允许添加新的字符，也可以是开放的，比如unicode，可以添加新的字符进去。要注意的是，抽象字符表是一个集合，集合有一个最大的特点就是无序的。
  编码字符集（Coded Character Set）   抽象字符表是抽象字符的集合，集合是无序的。无序的抽象字符表其实没什么卵用，因为我们只能判断一个字符在不在这个抽象字符表中，却无法方便的引用这个字符。为了更好的描述和操作字符，我们为抽象字符表中的每个抽象字符关联一个数字编号，这个数字编号叫做Code Point（译为码位），编码字符集就是为所有的字符都分配了码位的字符集。
  码位一般是非负整数，习惯上使用十六进制表示。码位的分配也不一定是连续的。
  最常见的编码字符集就是UCS（Universal Character Set），这也是unicode标准下使用的编码字符集
   - [0x0000,0xD7FF] 和 [0xE000,0x10FFFF] 这两个区间称为unicode标量值(unicode scala value) - [0xD800,0xDBFF] 称为 Hign-surrogate - [0xDC00,0xDFFF] 称为 Low-surrogate   字符编码表（Character Encoding Form）   当我们有了编码字符集之后，是不是所有的问题已经解决了呢，当然不是，上面提到过，字符集可以是开放的，所以理论上UCS需要的码位是无限的，但是就算是计算机中uint32，也只有4个字节，最多只能表示4294967295个码位，这样矛盾就出现了。解决这个矛盾的方案，就是字符编码表
  字符编码表是一个将Unicode标量值(Unicode scalar value)一一映射为码元序列(Code Unit Sequences)的映射。 之所以必须是一一映射，那是因为我们不光要编码，也要解码。 在Unicode中，指定了三种标准的字符编码表，UTF-8,UTF-16,UTF-32。分别将Unicode标量值映射为比特数为8、16、32的码元的序列。 即，UTF-8的码元为uint8, UTF-16的码元为uint16, UTF-32的码元为uint32。 当然也有一些非标准的CEF，如UCS-2,UCS-4，在此不多介绍。</description>
    </item>
    
  </channel>
</rss>
