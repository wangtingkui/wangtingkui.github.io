<!DOCTYPE html>
<html lang="en-us">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='上一篇文章中简单介绍了如何使用cobra框架，这篇文章让我们来看下cobra的源码，本文基于的cobra版本是v0.0.5
首先需要了解的是，在cobra中，所有的命令会组成一个树的结构，必然有一个根命令，我们应用的每次执行，都是从这个根命令开始的，官方文档也说过，基于cobra的应用的main包中的代码是很简单的，几乎没有额外的操作，仅有的操作其实就是执行我们的根命令。所以自然而然的，我们的代码分析之旅也是从根命令的执行开始的。
为了有个直观的感受，我简单生成了一个基于cobra的应用。这个应用有一个根命令和一个test1的子命令，项目结构如下：
╰─$ tree . . ├── LICENSE ├── cmd │ ├── root.go │ └── test1.go ├── go.mod ├── go.sum └── main.go 1 directory, 6 files 主线执行分析 所有的项目不可能都是简单的一条线到底，代码总会有很多分支，但我们阅读源码的时候精力和关注度总是有限的（不是有人说人在同一时间关注的点不能超过7个还是几个来着么），如果代码里面的每个分支都去看，每个函数的调用都进去瞅瞅，很快我们就会迷失在复杂的代码里面，忘了我们怎么看到的这行代码，所以本文去分析源码的时候，会优先挑一条主线，主要跟踪这条主线上的逻辑和调用，忽略其他支线。当然，也会有比较重要的其他支线，但是和当前的主线无关，会单开一个小节去阅读分析
cobra主线自然是入口-找到目标命令-分析参数-执行这条路径啦~
看下main.go文件中都有点啥
package main import &amp;#34;learnCobra/cmd&amp;#34; func main() { cmd.Execute() } 简洁的一比，直接进入cmd.Execute
func Execute() { if err := rootCmd.Execute(); err != nil { fmt.Println(err) os.Exit(1) } } 可以看到，其实就是执行了根命令的Execute方法，这个方法才是我们的重头戏。当然，所谓的根命令只是从命令的组织形态上来说的，所有的命令都是cobra.Command的这个结构体，后面绝大多数的代码也都是对这个结构体的成员和方法的分析
func (c *Command) Execute() error { _, err := c.ExecuteC() return err } 毫无波澜，直接进c.'><title>go cli 应用框架cobra（二）- 源码分析</title>

<link rel='canonical' href='https://wangtingkui.com/posts/go/cobra/'>

<link rel="stylesheet" href="/scss/style.min.8f4416a35036b6471a6978873128b5652464226c8db8a9620ed1b94bc11bd353.css"><meta property='og:title' content='go cli 应用框架cobra（二）- 源码分析'>
<meta property='og:description' content='上一篇文章中简单介绍了如何使用cobra框架，这篇文章让我们来看下cobra的源码，本文基于的cobra版本是v0.0.5
首先需要了解的是，在cobra中，所有的命令会组成一个树的结构，必然有一个根命令，我们应用的每次执行，都是从这个根命令开始的，官方文档也说过，基于cobra的应用的main包中的代码是很简单的，几乎没有额外的操作，仅有的操作其实就是执行我们的根命令。所以自然而然的，我们的代码分析之旅也是从根命令的执行开始的。
为了有个直观的感受，我简单生成了一个基于cobra的应用。这个应用有一个根命令和一个test1的子命令，项目结构如下：
╰─$ tree . . ├── LICENSE ├── cmd │ ├── root.go │ └── test1.go ├── go.mod ├── go.sum └── main.go 1 directory, 6 files 主线执行分析 所有的项目不可能都是简单的一条线到底，代码总会有很多分支，但我们阅读源码的时候精力和关注度总是有限的（不是有人说人在同一时间关注的点不能超过7个还是几个来着么），如果代码里面的每个分支都去看，每个函数的调用都进去瞅瞅，很快我们就会迷失在复杂的代码里面，忘了我们怎么看到的这行代码，所以本文去分析源码的时候，会优先挑一条主线，主要跟踪这条主线上的逻辑和调用，忽略其他支线。当然，也会有比较重要的其他支线，但是和当前的主线无关，会单开一个小节去阅读分析
cobra主线自然是入口-找到目标命令-分析参数-执行这条路径啦~
看下main.go文件中都有点啥
package main import &amp;#34;learnCobra/cmd&amp;#34; func main() { cmd.Execute() } 简洁的一比，直接进入cmd.Execute
func Execute() { if err := rootCmd.Execute(); err != nil { fmt.Println(err) os.Exit(1) } } 可以看到，其实就是执行了根命令的Execute方法，这个方法才是我们的重头戏。当然，所谓的根命令只是从命令的组织形态上来说的，所有的命令都是cobra.Command的这个结构体，后面绝大多数的代码也都是对这个结构体的成员和方法的分析
func (c *Command) Execute() error { _, err := c.ExecuteC() return err } 毫无波澜，直接进c.'>
<meta property='og:url' content='https://wangtingkui.com/posts/go/cobra/'>
<meta property='og:site_name' content='xiaok&#39;s blog'>
<meta property='og:type' content='article'><meta property='article:section' content='Posts' /><meta property='article:tag' content='go' /><meta property='article:tag' content='cobra' /><meta property='article:tag' content='源码分析' /><meta property='article:published_time' content='2019-12-11T14:57:37&#43;08:00'/><meta property='article:modified_time' content='2019-12-11T14:57:37&#43;08:00'/>
<meta name="twitter:title" content="go cli 应用框架cobra（二）- 源码分析">
<meta name="twitter:description" content="上一篇文章中简单介绍了如何使用cobra框架，这篇文章让我们来看下cobra的源码，本文基于的cobra版本是v0.0.5
首先需要了解的是，在cobra中，所有的命令会组成一个树的结构，必然有一个根命令，我们应用的每次执行，都是从这个根命令开始的，官方文档也说过，基于cobra的应用的main包中的代码是很简单的，几乎没有额外的操作，仅有的操作其实就是执行我们的根命令。所以自然而然的，我们的代码分析之旅也是从根命令的执行开始的。
为了有个直观的感受，我简单生成了一个基于cobra的应用。这个应用有一个根命令和一个test1的子命令，项目结构如下：
╰─$ tree . . ├── LICENSE ├── cmd │ ├── root.go │ └── test1.go ├── go.mod ├── go.sum └── main.go 1 directory, 6 files 主线执行分析 所有的项目不可能都是简单的一条线到底，代码总会有很多分支，但我们阅读源码的时候精力和关注度总是有限的（不是有人说人在同一时间关注的点不能超过7个还是几个来着么），如果代码里面的每个分支都去看，每个函数的调用都进去瞅瞅，很快我们就会迷失在复杂的代码里面，忘了我们怎么看到的这行代码，所以本文去分析源码的时候，会优先挑一条主线，主要跟踪这条主线上的逻辑和调用，忽略其他支线。当然，也会有比较重要的其他支线，但是和当前的主线无关，会单开一个小节去阅读分析
cobra主线自然是入口-找到目标命令-分析参数-执行这条路径啦~
看下main.go文件中都有点啥
package main import &amp;#34;learnCobra/cmd&amp;#34; func main() { cmd.Execute() } 简洁的一比，直接进入cmd.Execute
func Execute() { if err := rootCmd.Execute(); err != nil { fmt.Println(err) os.Exit(1) } } 可以看到，其实就是执行了根命令的Execute方法，这个方法才是我们的重头戏。当然，所谓的根命令只是从命令的组织形态上来说的，所有的命令都是cobra.Command的这个结构体，后面绝大多数的代码也都是对这个结构体的成员和方法的分析
func (c *Command) Execute() error { _, err := c.ExecuteC() return err } 毫无波澜，直接进c.">
    </head>
    <body class="
    article-page has-toc
">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "dark");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex 
    
        extended
    
">
    
        <div id="article-toolbar">
            <a href="/" class="back-home">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



                <span>返回</span>
            </a>
        </div>
    
<main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    

    <h2 class="article-title">
        <a href="/posts/go/cobra/">go cli 应用框架cobra（二）- 源码分析</a>
    </h2>

    

    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Dec 11, 2019</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 5 分钟
                </time>
            </div>
        
    </footer>
    
</div>
</header>

    <section class="article-content">
    
    
    <p>上一篇文章中简单介绍了如何使用<code>cobra</code>框架，这篇文章让我们来看下<code>cobra</code>的源码，本文基于的<code>cobra</code>版本是<code>v0.0.5</code></p>
<p>首先需要了解的是，在<code>cobra</code>中，所有的命令会组成一个树的结构，必然有一个根命令，我们应用的每次执行，都是从这个根命令开始的，官方文档也说过，基于<code>cobra</code>的应用的<code>main</code>包中的代码是很简单的，几乎没有额外的操作，仅有的操作其实就是执行我们的根命令。所以自然而然的，我们的代码分析之旅也是从根命令的执行开始的。</p>
<p>为了有个直观的感受，我简单生成了一个基于<code>cobra</code>的应用。这个应用有一个根命令和一个<code>test1</code>的子命令，项目结构如下：</p>
<pre tabindex="0"><code>╰─$ tree .
.
├── LICENSE
├── cmd
│   ├── root.go
│   └── test1.go
├── go.mod
├── go.sum
└── main.go

1 directory, 6 files
</code></pre><h3 id="主线执行分析">主线执行分析</h3>
<p>所有的项目不可能都是简单的一条线到底，代码总会有很多分支，但我们阅读源码的时候精力和关注度总是有限的（不是有人说人在同一时间关注的点不能超过7个还是几个来着么），如果代码里面的每个分支都去看，每个函数的调用都进去瞅瞅，很快我们就会迷失在复杂的代码里面，忘了我们怎么看到的这行代码，所以本文去分析源码的时候，会优先挑一条主线，主要跟踪这条主线上的逻辑和调用，忽略其他支线。当然，也会有比较重要的其他支线，但是和当前的主线无关，会单开一个小节去阅读分析</p>
<p><code>cobra</code>主线自然是<code>入口-找到目标命令-分析参数-执行</code>这条路径啦~</p>
<p>看下<code>main.go</code>文件中都有点啥</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;learnCobra/cmd&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">cmd</span><span class="p">.</span><span class="nf">Execute</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>简洁的一比，直接进入<code>cmd.Execute</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Execute</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">rootCmd</span><span class="p">.</span><span class="nf">Execute</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="nx">os</span><span class="p">.</span><span class="nf">Exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>可以看到，其实就是执行了根命令的<code>Execute</code>方法，这个方法才是我们的重头戏。当然，所谓的<em><strong>根命令</strong></em>只是从命令的组织形态上来说的，所有的命令都是<code>cobra.Command</code>的这个结构体，后面绝大多数的代码也都是对这个结构体的成员和方法的分析</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Command</span><span class="p">)</span> <span class="nf">Execute</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">ExecuteC</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre></div><p>毫无波澜，直接进<code>c.ExecuteC()</code>，这里开始我会在源码里面写点注释了</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Command</span><span class="p">)</span> <span class="nf">ExecuteC</span><span class="p">()</span> <span class="p">(</span><span class="nx">cmd</span> <span class="o">*</span><span class="nx">Command</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Regardless of what command execute is called on, run on Root only
</span><span class="c1"></span>	<span class="c1">// 前面说过，我们所有的命令构成了一棵树，每次执行都是从根命令开始执行的
</span><span class="c1"></span>	<span class="c1">// 如果我们手残在代码的某处直接执行了一个子命令，这个方法也会向上遍历到根，然后执行根命令的
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nf">HasParent</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Root</span><span class="p">().</span><span class="nf">ExecuteC</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="c1">// windows hook
</span><span class="c1"></span>	<span class="c1">// windows 系统的钩子，不用care
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">preExecHookFn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nf">preExecHookFn</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// initialize help as the last point possible to allow for user
</span><span class="c1"></span>	<span class="c1">// overriding
</span><span class="c1"></span>	<span class="c1">// 初始化默认的帮助命令，不是我们的主线，不care
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nf">InitDefaultHelpCmd</span><span class="p">()</span>

	<span class="nx">args</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">args</span>

	<span class="c1">// Workaround FAIL with &#34;go test -v&#34; or &#34;cobra.test -test.v&#34;, see #155
</span><span class="c1"></span>	<span class="c1">// 如果没有设置过命令的调用参数，使用os.Args[1:]作为默认参数
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">args</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">filepath</span><span class="p">.</span><span class="nf">Base</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="s">&#34;cobra.test&#34;</span> <span class="p">{</span>
		<span class="nx">args</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
	<span class="p">}</span>

	<span class="c1">// 找真正要执行的命令，并解析flag
</span><span class="c1"></span>	<span class="c1">// cobra为我们提供了两种flag，一种叫 persistant flag，
</span><span class="c1"></span>	<span class="c1">// 这种 flag 可以在子命令中也获取到
</span><span class="c1"></span>	<span class="c1">// 另外一种叫 local flag
</span><span class="c1"></span>	<span class="c1">// 这种 flag 只会在指定命令中被解析
</span><span class="c1"></span>	<span class="c1">// 默认情况下，cobra 只会解析目标命令的 local flag，父命令中的local flag将会被忽略
</span><span class="c1"></span>	<span class="c1">// 可以将命令的 TraverseChildren 属性置为 true ，cobra 会在执行命令前解析所有命令
</span><span class="c1"></span>	<span class="c1">// 的 local flag
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">flags</span> <span class="p">[]</span><span class="kt">string</span>
	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">TraverseChildren</span> <span class="p">{</span>
		<span class="nx">cmd</span><span class="p">,</span> <span class="nx">flags</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Traverse</span><span class="p">(</span><span class="nx">args</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// 我们当然是挑软柿子捏，当然挑这条简单的路走
</span><span class="c1"></span>		<span class="nx">cmd</span><span class="p">,</span> <span class="nx">flags</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="nx">args</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// If found parse to a subcommand and then failed, talk about the subcommand
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">cmd</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">c</span> <span class="p">=</span> <span class="nx">cmd</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">c</span><span class="p">.</span><span class="nx">SilenceErrors</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Error:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
			<span class="nx">c</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Run &#39;%v --help&#39; for usage.\n&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nf">CommandPath</span><span class="p">())</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="c1">// 记录这个命令被调用过了，和被调用的名字
</span><span class="c1"></span>	<span class="nx">cmd</span><span class="p">.</span><span class="nx">commandCalledAs</span><span class="p">.</span><span class="nx">called</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="k">if</span> <span class="nx">cmd</span><span class="p">.</span><span class="nx">commandCalledAs</span><span class="p">.</span><span class="nx">name</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nx">cmd</span><span class="p">.</span><span class="nx">commandCalledAs</span><span class="p">.</span><span class="nx">name</span> <span class="p">=</span> <span class="nx">cmd</span><span class="p">.</span><span class="nf">Name</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="c1">// 执行找到的命令
</span><span class="c1"></span>	<span class="nx">err</span> <span class="p">=</span> <span class="nx">cmd</span><span class="p">.</span><span class="nf">execute</span><span class="p">(</span><span class="nx">flags</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// Always show help if requested, even if SilenceErrors is in
</span><span class="c1"></span>		<span class="c1">// effect
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">flag</span><span class="p">.</span><span class="nx">ErrHelp</span> <span class="p">{</span>
			<span class="nx">cmd</span><span class="p">.</span><span class="nf">HelpFunc</span><span class="p">()(</span><span class="nx">cmd</span><span class="p">,</span> <span class="nx">args</span><span class="p">)</span>
			<span class="k">return</span> <span class="nx">cmd</span><span class="p">,</span> <span class="kc">nil</span>
		<span class="p">}</span>

		<span class="c1">// If root command has SilentErrors flagged,
</span><span class="c1"></span>		<span class="c1">// all subcommands should respect it
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nx">cmd</span><span class="p">.</span><span class="nx">SilenceErrors</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">c</span><span class="p">.</span><span class="nx">SilenceErrors</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Error:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
		<span class="p">}</span>

		<span class="c1">// If root command has SilentUsage flagged,
</span><span class="c1"></span>		<span class="c1">// all subcommands should respect it
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nx">cmd</span><span class="p">.</span><span class="nx">SilenceUsage</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">c</span><span class="p">.</span><span class="nx">SilenceUsage</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">cmd</span><span class="p">.</span><span class="nf">UsageString</span><span class="p">())</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">cmd</span><span class="p">,</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre></div><p>这里就有两个比较重要的方法了，<code>c.Find</code>和<code>cmd.execute</code>，我们先来看下怎么找到的目的命令</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Command</span><span class="p">)</span> <span class="nf">Find</span><span class="p">(</span><span class="nx">args</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Command</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 声明了一个函数类型的变量
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">innerfind</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">Command</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Command</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span>

	<span class="c1">// 定义了这个函数
</span><span class="c1"></span>	<span class="nx">innerfind</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Command</span><span class="p">,</span> <span class="nx">innerArgs</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Command</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// 去掉 flag， 剩下的就是参数
</span><span class="c1"></span>		<span class="nx">argsWOflags</span> <span class="o">:=</span> <span class="nf">stripFlags</span><span class="p">(</span><span class="nx">innerArgs</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">argsWOflags</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">innerArgs</span>
		<span class="p">}</span>
		<span class="c1">// 参数的第一个就是要执行的命令
</span><span class="c1"></span>		<span class="nx">nextSubCmd</span> <span class="o">:=</span> <span class="nx">argsWOflags</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

		<span class="c1">// 在子命令中去找有没有匹配 nextSubCmd 的子命令
</span><span class="c1"></span>		<span class="nx">cmd</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">findNext</span><span class="p">(</span><span class="nx">nextSubCmd</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">cmd</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// 递归的判断有没有匹配的子命令了
</span><span class="c1"></span>			<span class="k">return</span> <span class="nf">innerfind</span><span class="p">(</span><span class="nx">cmd</span><span class="p">,</span> <span class="nf">argsMinusFirstX</span><span class="p">(</span><span class="nx">innerArgs</span><span class="p">,</span> <span class="nx">nextSubCmd</span><span class="p">))</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">innerArgs</span>
	<span class="p">}</span>

	<span class="c1">// 调用了上面定义的那个函数，我擦，我也不知道作者为什么这样写
</span><span class="c1"></span>	<span class="c1">// 怕了怕了。。。先跳上去看逻辑吧
</span><span class="c1"></span>	<span class="nx">commandFound</span><span class="p">,</span> <span class="nx">a</span> <span class="o">:=</span> <span class="nf">innerfind</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">args</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">commandFound</span><span class="p">.</span><span class="nx">Args</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">commandFound</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nf">legacyArgs</span><span class="p">(</span><span class="nx">commandFound</span><span class="p">,</span> <span class="nf">stripFlags</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">commandFound</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">commandFound</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>然后我们再来看看<code>cmd.execute</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Command</span><span class="p">)</span> <span class="nf">execute</span><span class="p">(</span><span class="nx">a</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 如果命令是个nil，那还执行个蛋
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;Called Execute() on a nil Command&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 通过 Deprecated 这个属性判断这个命令是否将要被废弃
</span><span class="c1"></span>	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Deprecated</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Command %q is deprecated, %s\n&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Name</span><span class="p">(),</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Deprecated</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// initialize help and version flag at the last point possible to allow for user
</span><span class="c1"></span>	<span class="c1">// overriding
</span><span class="c1"></span>	<span class="c1">// 添加默认的帮助flag和版本flag
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nf">InitDefaultHelpFlag</span><span class="p">()</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">InitDefaultVersionFlag</span><span class="p">()</span>

	<span class="c1">// 解析flag
</span><span class="c1"></span>	<span class="nx">err</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">ParseFlags</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">FlagErrorFunc</span><span class="p">()(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// If help is called, regardless of other flags, return we want help.
</span><span class="c1"></span>	<span class="c1">// Also say we need help if the command isn&#39;t runnable.
</span><span class="c1"></span>	<span class="c1">// 如果使用了帮助flag，忽略其他的flag
</span><span class="c1"></span>	<span class="nx">helpVal</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Flags</span><span class="p">().</span><span class="nf">GetBool</span><span class="p">(</span><span class="s">&#34;help&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// should be impossible to get here as we always declare a help
</span><span class="c1"></span>		<span class="c1">// flag in InitDefaultHelpFlag()
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;\&#34;help\&#34; flag declared as non-bool. Please correct your code&#34;</span><span class="p">)</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="c1">// 如果指定了帮助flag，返回一个帮助类型错误，上层会处理，调用命令的 HelpFunc
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">helpVal</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">flag</span><span class="p">.</span><span class="nx">ErrHelp</span>
	<span class="p">}</span>

	<span class="c1">// for back-compat, only add version flag behavior if version is defined
</span><span class="c1"></span>	<span class="c1">// 如果设置了Version属性，并且传递了 version flag，输出版本信息
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Version</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nx">versionVal</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Flags</span><span class="p">().</span><span class="nf">GetBool</span><span class="p">(</span><span class="s">&#34;version&#34;</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;\&#34;version\&#34; flag declared as non-bool. Please correct your code&#34;</span><span class="p">)</span>
			<span class="k">return</span> <span class="nx">err</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">versionVal</span> <span class="p">{</span>
			<span class="nx">err</span> <span class="o">:=</span> <span class="nf">tmpl</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">OutOrStdout</span><span class="p">(),</span> <span class="nx">c</span><span class="p">.</span><span class="nf">VersionTemplate</span><span class="p">(),</span> <span class="nx">c</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">c</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="nx">err</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// 判断是否可运行（也就是是否设置了命令的 Run 或者 RunE 属性）
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">c</span><span class="p">.</span><span class="nf">Runnable</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">flag</span><span class="p">.</span><span class="nx">ErrHelp</span>
	<span class="p">}</span>

	<span class="c1">// 执行准备，其实就是执行通过cobra.OnInitialize注册的初始化方法
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nf">preRun</span><span class="p">()</span>

	<span class="c1">// 获取所有flag之外的参数
</span><span class="c1"></span>	<span class="nx">argWoFlags</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Flags</span><span class="p">().</span><span class="nf">Args</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">DisableFlagParsing</span> <span class="p">{</span>
		<span class="c1">// 如果设置了 DisableFlagParsing 为 false
</span><span class="c1"></span>		<span class="c1">// 也就是不解析 flag，把所有的参数当做命令的参数
</span><span class="c1"></span>		<span class="nx">argWoFlags</span> <span class="p">=</span> <span class="nx">a</span>
	<span class="p">}</span>

	<span class="c1">// 通过命令的 Args 属性设置的方法验证我们的参数
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">ValidateArgs</span><span class="p">(</span><span class="nx">argWoFlags</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="c1">// PersistentPreRun 钩子函数
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">p</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">;</span> <span class="nx">p</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">p</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">Parent</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">PersistentPreRunE</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">PersistentPreRunE</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">argWoFlags</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nx">err</span>
			<span class="p">}</span>
			<span class="k">break</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">PersistentPreRun</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">p</span><span class="p">.</span><span class="nf">PersistentPreRun</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">argWoFlags</span><span class="p">)</span>
			<span class="k">break</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// PreRun 钩子函数
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">PreRunE</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">PreRunE</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">argWoFlags</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">err</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">PreRun</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nf">PreRun</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">argWoFlags</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// 验证所有必要的flag
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">validateRequiredFlags</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="c1">// 执行自定义逻辑函数
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">RunE</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">RunE</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">argWoFlags</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">err</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">argWoFlags</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// PostRun 钩子
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">PostRunE</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">PostRunE</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">argWoFlags</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">err</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">PostRun</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nf">PostRun</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">argWoFlags</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// PersistentPostRun 钩子
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">p</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">;</span> <span class="nx">p</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">p</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">Parent</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">PersistentPostRunE</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">PersistentPostRunE</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">argWoFlags</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nx">err</span>
			<span class="p">}</span>
			<span class="k">break</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">PersistentPostRun</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">p</span><span class="p">.</span><span class="nf">PersistentPostRun</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">argWoFlags</span><span class="p">)</span>
			<span class="k">break</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>到此，大概的命令执行流程我们就分析完了。可以发现，这次的分析过程，我们并没有预先把<code>cobra.Command</code>结构里面的成员先看一遍，因为里面的成员实在是太太太多了，简单看一遍几乎是秒忘，所以对于这种成员非常多的结构体，建议直接跟流程，看到用什么成员，再去结构里看这个成员的说明。</p>
<p>以上就是我们的整个分析过程了，如果有空，之后会补充一些重要的支线逻辑</p>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/go/">go</a>
        
            <a href="/tags/cobra/">cobra</a>
        
            <a href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
</article>

    

    <aside class="related-contents--wrapper">
    
    
</aside>

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2022 xiaok&#39;s blog
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.7.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer="true"
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >

            </main>
    
        <aside class="sidebar right-sidebar sticky">
            <section class="widget archives">
                <div class="widget-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



                </div>
                <h2 class="widget-title section-title">目录</h2>
                
                <div class="widget--toc">
                    <nav id="TableOfContents">
  <ol>
    <li>
      <ol>
        <li><a href="#主线执行分析">主线执行分析</a></li>
      </ol>
    </li>
  </ol>
</nav>
                </div>
            </section>
        </aside>
    

        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                defer="false"
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
