{"categories":[{"title":"go三方库使用","uri":"https://wangtingkui.github.io/categories/go%E4%B8%89%E6%96%B9%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"title":"go基础","uri":"https://wangtingkui.github.io/categories/go%E5%9F%BA%E7%A1%80/"},{"title":"Go标准库使用","uri":"https://wangtingkui.github.io/categories/go%E6%A0%87%E5%87%86%E5%BA%93%E4%BD%BF%E7%94%A8/"},{"title":"php基础","uri":"https://wangtingkui.github.io/categories/php%E5%9F%BA%E7%A1%80/"},{"title":"使用hugo搭建个人网站","uri":"https://wangtingkui.github.io/categories/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/"},{"title":"工具","uri":"https://wangtingkui.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"posts":[{"content":"Go 的一大特点就是在语言级别实现了并发，一旦涉及并发，那么不可避免的就需要同步，来确保多个 goroutine 在访问共享资源的时候不会出现混乱的状况\nGo 中的 sync 包提供了常见的并发编程同步原语，我们接下来就看下各种同步的方式如何使用，以及不同的同步方式都适用于什么样的场景，从而能让我们在日常使用中可以有针对性的挑选\nsync.Mutex sync.Mutex 是使用最广泛的一种原语，它保证同一时刻，只有一个 goroutine 可以访问临界资源，也就是我们常说的互斥锁\nm := \u0026amp;sync.Mutex{} m.Lock() // 临界区 m.Unlock() sync.RWMutex sync.RWMutex 是一个读写锁，它有两种锁的方式，读锁和写锁，当一个 goroutine 成功获取读锁的时候，其他 goroutine 也可以成功获取读锁，但是无法获取写锁。如果一个 goroutine 成功获取了写锁的时候，其他 goroutine 读锁和写锁都无法获得\nsync.RWMutex是基于sync.Mutex实现的，具体原理在这里就不多说了，可以看下另外一篇文章\nm := sync.RWMutex{} m.Lock() // 执行一些写操作 m.Unlock() m.RLock() // 执行一些可以并发的读操作 m.RUnlock() sync.RWMutex常用于读写场景都有，但是读场景远远多于写场景的情况\nsync.WaitGroup sync.WaitGroup 常常用来等待一组 goroutine 执行完成\nwg := \u0026amp;sync.WaitGroup{} wg.Add(2) go func() { wg.Done() }() go func() { wg.Done() }() wg.Wait() sync.Map Go 中的 map 类型本身是非并发安全的，如果在并发场景下，必须加锁来保证数据安全，sync.Map是一个并发版本的map，可以直接在并发场景下使用\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) func main() { m := sync.Map{} // 添加元素 \tm.Store(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;) // 获取元素 \tif v, ok := m.Load(\u0026#34;key\u0026#34;); ok { fmt.Println(v.(string)) } else { fmt.Println(\u0026#34;key is not exists\u0026#34;) } // 返回指定key，如果不存在，使用给定的值设置到map中 \tif v, loaded := m.LoadOrStore(\u0026#34;k\u0026#34;, \u0026#34;value\u0026#34;); loaded { fmt.Println(\u0026#34;读取到\u0026#34;, v) } else { fmt.Println(\u0026#34;存入\u0026#34;, v) } // 删除元素 \tm.Delete(\u0026#34;k\u0026#34;) // 遍历元素 \tm.Range(func(k, v interface{}) bool { fmt.Println(v.(string)) // 如果返回 false，则停止迭代 \treturn true }) } 当我们的场景是写入不频繁但是读取特别频繁，或者多个 goroutine 的map写入区间不同的时候，使用sync.Map比普通 map 配合 mutex 效果要好很多\nsync.Pool sync.Pool是一个并发安全的对象池，当我们想重用长期存在的共享对象或者想优化内存使用的收，可以尝试使用sync.Pool\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) func main() { type V struct { v int } pool := sync.Pool{} pool.Put(V{1}) pool.Put(V{2}) pool.Put(V{3}) fmt.Println(pool.Get().(V).v) fmt.Println(pool.Get().(V).v) fmt.Println(pool.Get().(V).v) } sync.Once sync.Once可以保证一个函数只被执行一次\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) func main() { once := \u0026amp;sync.Once{} for i := 1; i \u0026lt; 3; i++ { j := i go func() { once.Do(func() { fmt.Println(j) }) }() } time.Sleep(time.Second) } sync.Cond sync.Cond常常用来处理的场景是：当一个数据状态发生变化的时候，通知其他等待的 goroutine\n它的原理就是维护了一个等待队列，当变量满足条件的时候，通知队列中等待的 goroutine\n使用 sync.Cond 的时候有几个注意点：\n 需要确保想要唤醒的 goroutine 已经进入 wait 状态 在调用 wait 前需要加锁（主要是为了确保互斥的修改等待队列）  由于条件变量需要和锁配合使用，如果使用不严谨容易发生死锁，所以建议尽量少用\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) func main() { cond := sync.NewCond(\u0026amp;sync.Mutex{}) for i := 1; i \u0026lt;= 10; i++ { go func(x int) { cond.L.Lock() cond.Wait() cond.L.Unlock() fmt.Println(x) }(i) } // 保证所有 goroutine 都进入 wait 状态 \ttime.Sleep(time.Second) // 释放一个 \tcond.Signal() // 隔一秒在释放一个 \ttime.Sleep(time.Second) cond.Signal() // 全部释放 \ttime.Sleep(time.Second) cond.Broadcast() time.Sleep(time.Second) } ","id":0,"section":"posts","summary":"Go 的一大特点就是在语言级别实现了并发，一旦涉及并发，那么不可避免的就需要同步，来确保多个 goroutine 在访问共享资源的时候不会出现混乱的状况 Go 中的 sync 包提","tags":["go"],"title":"Go标准库（sync）- 使用","uri":"https://wangtingkui.github.io/2020/06/sync/","year":"2020"},{"content":"go 中的 Context 的主要作用是在多个 groutine 之间同步取消信号或者截止日期，用于减少对资源的消耗和长时间占用，避免资源浪费。也可以利用 Context 来进行值的传递，但是使用比较少\n使用 Context 本身是 context 包对外暴露的一个接口\ntype Context interface { Deadline() (deadline time.Time, ok bool) // 返回当前 Context 的截止日期  Done() \u0026lt;-chan struct{} // 返回一个 channel，这个channel会在 Context 截止日期到了或者被取消之后关闭，多次调用Done会返回同一个channel  Err() error // 表明 Done 的原因，如果是超时，为DeadlineExceeded错误。如果是被取消，则是Canceled错误  Value(key interface{}) interface{} // 返回Context中key对应的value } 当前 go 中为我们提供了多个方法来创建 Context：\n context.TODO 和 context.Background，这两个方法都是返回一个预先实例化好的空 context 对象，如果没有特殊需求，所有的 context 应该都基于 context.Background来创建 context.WithCancel，创建可取消的上下文 context.WithDeadline，创建有超时时间的上下文 context.WithTimeout，对 context.WithDeadline的封装，更容易使用 context.WithValue，创建有键值对的上下文  一个简单的使用 demo：\nfunc main() { ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second) defer cancel() go handle(ctx, 500*time.Millisecond) select { case \u0026lt;-ctx.Done(): fmt.Println(\u0026#34;main\u0026#34;, ctx.Err()) } } func handle(ctx context.Context, duration time.Duration) { select { case \u0026lt;-ctx.Done(): fmt.Println(\u0026#34;handle\u0026#34;, ctx.Err()) case \u0026lt;-time.After(duration): fmt.Println(\u0026#34;process request with\u0026#34;, duration) } } 输出：\n$ go run context.go process request with 500ms main context deadline exceeded 使用 context 同步信号，取消 goroutine执行的最佳实践 参考：学会使用context取消goroutine执行的方法\n参考  大神是如何学习 Go 之并发编程与 Context 学会使用context取消goroutine执行的方法  ","id":1,"section":"posts","summary":"go 中的 Context 的主要作用是在多个 groutine 之间同步取消信号或者截止日期，用于减少对资源的消耗和长时间占用，避免资源浪费。也可以利用 Context 来进行值的传递，但是使","tags":["go"],"title":"go中Context的使用","uri":"https://wangtingkui.github.io/2020/06/context/","year":"2020"},{"content":"在 go 官方的标准库中，提供了 net/smtp 库可以让我们使用 smtp 协议来发送邮件，但是这个库使用起来不是很方便，而且官方也不再维护这个库，推荐我们使用功能更丰富的第三方库来处理邮件发送\njordan-wright/email就是一个使用的比较多的用来处理邮件发送的类库，它底层还是基于net/smtp实现的，但是提供了方便的调用方式供使用者使用\n安装 go get github.com/jordan-wright/email\n使用demo e := email.NewEmail() e.From = \u0026#34;Jordan Wright \u0026lt;test@gmail.com\u0026gt;\u0026#34; e.To = []string{\u0026#34;test@example.com\u0026#34;} e.Bcc = []string{\u0026#34;test_bcc@example.com\u0026#34;} e.Cc = []string{\u0026#34;test_cc@example.com\u0026#34;} e.Subject = \u0026#34;Awesome Subject\u0026#34; e.Text = []byte(\u0026#34;Text Body is, of course, supported!\u0026#34;) e.HTML = []byte(\u0026#34;\u0026lt;h1\u0026gt;Fancy HTML is supported, too!\u0026lt;/h1\u0026gt;\u0026#34;) e.Send(\u0026#34;smtp.gmail.com:587\u0026#34;, smtp.PlainAuth(\u0026#34;\u0026#34;, \u0026#34;test@gmail.com\u0026#34;, \u0026#34;password123\u0026#34;, \u0026#34;smtp.gmail.com\u0026#34;)) 可以看到这个类库调用起来还是非常的语义化的\n更多的使用可以参考官方文档\n","id":2,"section":"posts","summary":"在 go 官方的标准库中，提供了 net/smtp 库可以让我们使用 smtp 协议来发送邮件，但是这个库使用起来不是很方便，而且官方也不再维护这个库，推荐我们使用功能更丰富","tags":["go"],"title":"使用 jordan-wright/email 处理邮件发送","uri":"https://wangtingkui.github.io/2020/06/mail/","year":"2020"},{"content":"channel 类型 go 中 channel 类型分为两类：\n 带缓冲区的channel，定义方式如：ch := make(chan int, 2) 不带缓冲区的channel，定义方式如：ch := make(chan int)  不带缓冲区的 channel，写入和读取都会阻塞，在使用的时候必须有对应的写入 goroutine 和读取 goroutine，否则会造成死锁；带缓冲区的 channel，在缓冲区没满的时候会先将数据发到缓冲区，然后立即返回，如果缓冲区满了，会阻塞 goroutine\n为了操作上的安全和可读性，我们还可以限制 channel 的读写属性，默认 channel 都是可读可写的，可以使用 \u0026lt;-chan 来限定只读 channel， 使用chan\u0026lt;-来限定只写 channel，需要注意的是，只读的channel是不能关闭的\nfunc main() { ch := make(chan int, 10) go func(ch chan\u0026lt;- int) { for i := 0; i \u0026lt; 10; i++ { ch \u0026lt;- 1 // 这里如果使用 \u0026lt;- ch，编译是不通过的 \t} close(ch) }(ch) for i := 0; i \u0026lt; 10; i++ { fmt.Println(\u0026lt;-ch) } } 最重要的一点：channel 必须初始化后才能使用\nchannel 操作 创建 // 不带缓冲区的 channel ch := make(chan int) // 带10个缓冲区的 channel bufferedChannel := make(chan int, 10) 关闭操作 close(ch) 注意，不能在已经关闭的 channel 上调用 close，会panic：panic: close of closed channel\n写操作 ch := make(chan int, 10) ch \u0026lt;- 1 注意，如果已经 close 的 channel 不能再写入，如果执行写入操作会 panic：send on closed channel\n读操作 value := \u0026lt;- ch 注意，被关闭的 channel 也能正常读取，但是读取到的永远是 channel 类型的零值，可以通过接受读取操作返回的第二个值确定读取的零值是不是因为 channel 关闭而读到的\nfunc main() { ch := make(chan int, 1) ch \u0026lt;- 1 val, ok := \u0026lt;-ch fmt.Println(val, ok) // 1 true close(ch) val, ok = \u0026lt;-ch fmt.Println(val, ok) // 0 false } range 操作 使用 range 关键字来操作 channel 其实也是读的一种，只不过处理起来更方便，也更易阅读\nrange 可以持续的从一个 channel 读取数据，如果 channel 被关闭，读取完数据之后会自动退出循环\nfunc makeSomeData(ch chan int, size int) { for i := 0; i \u0026lt; size; i++ { ch \u0026lt;- i } close(ch) } func main() { ch := make(chan int, 10) go makeSomeData(ch, 100) for num := range ch { fmt.Println(num) } } select 操作 当 chan 缓冲区满的时候，再往里面写入的时候会阻塞，或者 chan 里面没有数据，想从里面读数据的时候，也会阻塞，如果我们不想让 goroutine 阻塞，可以使用 select\nselect的执行流程是这样的：\n 检测每个case代码块 如果任意一个case代码块追备好发送或者接受，执行对应内容 如果有一个以上的代码块准备好了发送或者接受数据，随机选取一个执行 如果所有的case代码块都没准备好，则阻塞等待 如果所有的case代码块都没准备好，但是有default代码块，则执行default代码块  c := make(chan int, 10) for { select { case v := \u0026lt;-c: fmt.Println(v) default: fmt.Println(\u0026#34;暂无数据\u0026#34;) time.Sleep(time.Second) } } ","id":3,"section":"posts","summary":"channel 类型 go 中 channel 类型分为两类： 带缓冲区的channel，定义方式如：ch := make(chan int, 2) 不带缓冲区的channel，定义方式如：ch := make(chan int) 不带缓冲区的 c","tags":["go"],"title":"go中channel的使用","uri":"https://wangtingkui.github.io/2020/06/channel/","year":"2020"},{"content":"在vmware funsion上安装完centos7后，不经过配置的话网络是无法使用的，下面看下如何给新安装的 centos7 虚拟机配置 NAT 模式的网络\n一、确定网络信息 vmnet8是安装 vmware funsion 之后自动生成的一张虚拟网卡，NAT 模式使用的就是这张网卡\n进入vmnet8网卡配置目录 \u0026gt; cd /Library/Preferences/VMware Fusion/vmnet8 查看nat信息，记住nat网关信息，也就是ip和netmask字段 \u0026gt; cat nat.conf nat.conf 文件内容：\n... # 省略文件其他部分 [host] # NAT gateway address ip = 172.16.5.2 netmask = 255.255.255.0 ... # 省略文件其他部分 查看dhcp信息，记住range范围，这里指的就是可用ip范围 \u0026gt; cat dhcpd.conf dhcpd.conf 文件信息：\n... # 省略文件其他部分 subnet 172.16.5.0 netmask 255.255.255.0 { range 172.16.5.128 172.16.5.254; option broadcast-address 172.16.5.255; option domain-name-servers 172.16.5.2; option domain-name localdomain; default-lease-time 1800; # default is 30 minutes max-lease-time 7200; # default is 2 hours option netbios-name-servers 172.16.5.2; option routers 172.16.5.2; } ... # 省略文件其他部分 确定dns 在系统偏好设置中的网络查看当前主机的dns配置\n配置虚拟机网络设置 在设置中将网络模式设置为共享\n设置centos7网络 登录虚拟机，配置 centos7 的网卡\n\u0026gt; vim /etc/sysconfig/network-scripts/ifcfg-ens33 上面部分ifcfg-ens33是网卡名称，不同的虚拟机有可能会变，这个注意下\n按照下面红框部分进行设置\n BOOTPROTO=static：设置为固定ip ONBOOT=yes: 设置开启网卡 IPADDR=172.16.5.200: 使用哪个静态ip GATEWAY=172.16.5.2: 刚才看的vmnet8的网关 NETMAST=255.255.255.0: vmnet8的掩码 DNS1=192.168.50.1: DNS  重启网卡 \u0026gt; service network restart ","id":4,"section":"posts","summary":"在vmware funsion上安装完centos7后，不经过配置的话网络是无法使用的，下面看下如何给新安装的 centos7 虚拟机配置 NAT 模式的网络 一、确定","tags":["vmware"],"title":"VMware funsion 安装 centos7 后配置 NAT 网络","uri":"https://wangtingkui.github.io/2020/05/net-fix-on-centos-7/","year":"2020"},{"content":"plex 是一个跨平台的家庭影音中心，基本上使用nas的小伙伴都会使用它来搭建自己的影音中心，他可以根据影片名称和年份信息自动拉取其他元信息（封面、演员等），易用程度和美观程度都非常高\n本片文章主要写一下 plex 在群辉nas上的基本使用\n第一步 安装 Plex Media Server 套件\n第二步 根据步骤注册 plex 账号\n第三步 点击头像旁边的+号，添加资料库\n选择要添加的资料库类型，官网强烈建议不同的媒体类型分类存储，比如电影和电视剧最好分开，否则可能会造成元信息搜索不到或者不准确\n这里假设我们要创建电影类型的资料库\n选择文件夹的时候要注意，plex只能展示第一层文件夹，比如我们的电影存储路径在/a/b/c，plex只能展示/a/b，所以这里我们最好是直接手动输入电影路径\n点击添加就好了\n第四步 通常在完成上面的操作后还是扫描不到文件夹里面的电影，这是因为 plex 没有对电影所在文件夹的操作权限，所以需要我们手动添加一下\n打开file station选中我们电影存储的文件夹，右键选择属性，点击权限，新增，给plex账户添加读写权限即可\n","id":5,"section":"posts","summary":"plex 是一个跨平台的家庭影音中心，基本上使用nas的小伙伴都会使用它来搭建自己的影音中心，他可以根据影片名称和年份信息自动拉取其他元信息（封面、","tags":["nas"],"title":"群辉nas使用plex套件","uri":"https://wangtingkui.github.io/2020/05/plex/","year":"2020"},{"content":"vscode 扩展推荐\n实用    扩展名 用途    推荐主题    主题名 备注     vscode-icons 可以替换vscode的默认图标   Atom One Dark Theme    Monokai Pro     ","id":6,"section":"posts","summary":"vscode 扩展推荐 实用 扩展名 用途 推荐主题 主题名 备注 vscode-icons 可以替换vscode的默认图标 Atom One Dark Theme Monokai Pro","tags":["vscode"],"title":"vscode推荐扩展","uri":"https://wangtingkui.github.io/2020/05/extension/","year":"2020"},{"content":"如果有多台电脑，可以使用 alfred 提供的配置同步功能来进行配置同步，以保证在多台电脑间的无缝使用\nalfred 的同步功能本质上是将配置打包成一个文件，然后借助第三方云同步功能同步这个文件，所以首先我们需要有个可用的云同步的文件夹，alfred 官方推荐的是 dropbox，但是由于一些不可描述的原因在国内使用起来不是很方便，所以这里我推荐另外一个软件，坚果云\n具体坚果云的配置非常简单，这里就不赘述了，下面说一下怎么开启 alfred 的同步功能\n配置  打开偏好设置 找到Advanced配置项 右下角一个 Syncing 的配置 点击 Set preferences folder.. 按钮，选择我们的云同步文件夹就好了  ","id":7,"section":"posts","summary":"如果有多台电脑，可以使用 alfred 提供的配置同步功能来进行配置同步，以保证在多台电脑间的无缝使用 alfred 的同步功能本质上是将配置打包成一个文件，然后借助第","tags":["alfred"],"title":"alfred配置同步","uri":"https://wangtingkui.github.io/2020/05/sync-setting/","year":"2020"},{"content":"单测能够极大的提升rd的回归效率（也能极大的提升开发效率），go内置了完整的单测支持\n单测基本规则  单元测试文件必须以_test.go结尾 单元测试文件名前面的部分最好和要被测试的方法所在的文件名保持一致 单元测试函数名称必须要以TestXxxx的格式书写，函数必须要接受一个testing.T类型的指针，不能有返回值 单元测试函数名最好能和被测试的函数保持对应，比如要测试的方法是Add，那么单测函数的名字最好是TestAdd，如果被测试的方法在同一个包下的多个结构体中都有，那么单测函数的名字可以是Test结构体名字_方法名，比如TestMyStruct_Add  一个demo 包文件结构\n❯ tree . ├── main.go └── main_test.go 0 directories, 2 files main.go文件内容\npackage main func Add(x, y int) int { return x + y } func main() { } main_test.go内容\npackage main import ( \u0026quot;testing\u0026quot; ) func TestAdd(t *testing.T) { if Add(1, 2) != 3 { t.Errorf(\u0026quot;test add func err\u0026quot;) } } 执行结果\n❯ go test PASS ok test-go/unit-testing\t0.006s 使用testing.T标记单测成功和纪录运行时日志 可以看到，我们的单测方法都需要接受一个testing.T类型的指针，testing.T类型用于管理测试状态并支持格式化测试日志，测试日志会在执行测试的过程中不断积累，在这个单元测试方法结束的时候输出到标准输出\n测试函数结束的方式：\n 当测试函数返回的时候 调用FailNow、Fatal、Fatalf、SkipNow、Skip、Skipf中的任意一个，测试宣告结束  常用的报告方法：\n 纪录运行时的日志，不会对运行产生日和信息\n Log:输出信息 Logf:格式化输出信息\n 遇到断言错误，想要标识这个测试失败\n Fail:标记测试失败，但是测试还会继续，之后的代码会继续执行 FailNow:标记测试失败，测试终端，也就是之后的代码不会在执行了 Error:相当于Log + Fail Errorf:相当于Logf + Fail Fatal:相当于Log + FailNow Fatalf:相当于Logf + FailNow\n 遇到断言错误，希望跳过这个错误，不标记为失败\n SkipNow:跳过测试，测试中断 Skip:相当于Log + SkipNow Skipf:相当于Logf + SkipNow\n执行单测 执行单测的对象可以是以下三种：\n 包的导入路径go test \u0026lt;package_import_path\u0026gt; 如果当前在包的路径下，可以直接执行go test，会执行当前包下所有单测 可以测试单独文件go test path_of_a.go path_of_a_test.go  下面是常用的一些指令\n# 执行当前包中的单测 go test # 执行指定包的单测（注意使用的是包的导入路径） go test testproject # go test 默认只会输出最后包的测试结果，如果想要看中间的测试过程和输出，使用下面的命令 go test -v # 测试指定文件 go test -v a.go a_test.go # 测试指定方法，使用test.run变量可以用正则过滤要执行 go test -v -test.run TestFunc 使用TestMain进行额外的setup（设置）或teardown（拆卸） 很多情况下，我们的多个测试case会依赖同一段初始化逻辑，这时候我们要么在每个测试函数中重复书写初始化代码，要么会将初始化逻辑封装成一个函数，然后在测试函数中调用。\ngo 的 testing 包提供了 TestMain(* testing.M)函数，如果测试文件中包含该函数，那么生成的测试将调用 TestMain(m)，而不是直接运行测试。TestMain 运行在主 goroutine 中 , 可以在调用 m.Run 前后做任何设置和拆卸。注意，在 TestMain 函数的最后，应该使用 m.Run 的返回值作为参数调用 os.Exit\n下面是一个demo（测试main包中的Add函数）\npackage main import ( \u0026#34;flag\u0026#34; \u0026#34;os\u0026#34; \u0026#34;testing\u0026#34; ) var result int func TestMain(m *testing.M) { flag.Parse() result = 2 os.Exit(m.Run()) } func TestAdd(t *testing.T) { if Add(1, 1) != result { t.Fatal() } } 注意事项 禁用缓存 当功能代码和测试代码都没有改动的时候，go test会在下次执行的时候直接取用缓存中的结果，并在执行结果中标记cached字样，如下图：\n如果禁用缓存，需要在执行单测的时候添加-count=1的参数:go test . -count=1 -v\n注意init函数的影响 如果执行的单测是包级别的，那么go test会执行包内的init函数，可能会影响测试结果\n单测覆盖率 go 也提供了检测单测覆盖率的工具，可以帮助我们快速定位没有包含在单测范围内的代码，可以在执行单测时添加-coverprofile选项开启\n-coverprofile 的值是覆盖率相关数据导出的文件名称\ngo test -coverprofile=c.out 首先可以看到覆盖率已经随着命令行输出\n╰─$ go test -coverprofile=c.out PASS coverage: 50.0% of statements ok timing/sub\t0.012s 然后通过go tool cover工具分析哪些代码不在单测涵盖的范围内，通过以下命令将刚才生成的覆盖率文件生成可视的html文件\ngo tool cover -html=c.out -o=info.html\n打开生成的html文件，可以看到工具已经为我们标记除了已经覆盖的（绿色）和未覆盖（红色）的代码了\n参考  http://blog.studygolang.com/2017/10/how-to-test-with-go/ https://books.studygolang.com/The-Golang-Standard-Library-by-Example/chapter09/09.0.html  ","id":8,"section":"posts","summary":"单测能够极大的提升rd的回归效率（也能极大的提升开发效率），go内置了完整的单测支持 单测基本规则 单元测试文件必须以_test.go结尾 单元测","tags":["go"],"title":"在go中使用单元测试","uri":"https://wangtingkui.github.io/2020/05/unit-testing/","year":"2020"},{"content":"atom 是一个插件化的编辑器，使用合适的插件可以极大的提升我们的使用效率，下面推荐一些我自己常用的插件\nproject-manager（atom项目管理） 可以将文件保存为项目，方便管理。我一般会配合 alfred workflow 方便的打开自己想要的项目\nsync-settings（atom配置同步） 如果使用多台电脑，必不能少的插件，将atom配置同步到 github gist 来达到同步目的\npretty-json（json格式化） 开发中经常用的，可以对json字符串进行格式化\nide-yaml（yaml格式化和校验） yaml格式化和校验\npp-markdown（markdown预览） markdown预览\natom-beautify（代码格式化） 代码格式化\ncss-snippets（css代码提示） 支持css、scss、sass、less\n","id":9,"section":"posts","summary":"atom 是一个插件化的编辑器，使用合适的插件可以极大的提升我们的使用效率，下面推荐一些我自己常用的插件 project-manager（atom项目","tags":["atom"],"title":"推荐的atom插件","uri":"https://wangtingkui.github.io/2020/05/pakage/","year":"2020"},{"content":"和插件一样，zsh 为我们提供了丰富的主题和自定义主题的能力，主题也分为两大类，一类是内置主题，另一类是自定义的扩展主题\n内置主题 这个其实没啥好说的，在官网浏览下，挑选自己喜欢的，然后再~/.zshrc中配置对应的主题名称就行\n以官网中下图这个主题为例，主题名字叫robbyrussell\n在配置文件中修改ZSH_THEME变量的值即可\n# Set name of the theme to load --- if set to \u0026#34;random\u0026#34;, it will # load a random theme each time oh-my-zsh is loaded, in which case, # to know which specific one was loaded, run: echo $RANDOM_THEME # See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes ZSH_THEME=\u0026#34;robbyrussell\u0026#34; 自定义主题（也称为外部主题） 这种主题类似插件，需要下载到${ZSH_CUSTOM}/themes这个目录下，然后再去配置文件中配置即可\n下面以一个超推荐的外部主题powerlevel10k/powerlevel10k为例，超级强大和漂亮（已经超越了主题的范畴）\n step1\n 先下载主题：git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/themes/powerlevel10k\n step2\n 修改主题\n# Set name of the theme to load --- if set to \u0026#34;random\u0026#34;, it will # load a random theme each time oh-my-zsh is loaded, in which case, # to know which specific one was loaded, run: echo $RANDOM_THEME # See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes ZSH_THEME=\u0026#34;powerlevel10k/powerlevel10k\u0026#34;  step3\n 重新启动终端\n step4\n 按照主题的安装向导进行配置（没错，主题带了安装向导。。。）\n配置完之后，就可以快乐的使用了，如果之后对设置不满意，可以重新运行设置向导p10k configure\n","id":10,"section":"posts","summary":"和插件一样，zsh 为我们提供了丰富的主题和自定义主题的能力，主题也分为两大类，一类是内置主题，另一类是自定义的扩展主题 内置主题 这个其实没啥好","tags":[],"title":"使用zsh主题","uri":"https://wangtingkui.github.io/2020/05/theme/","year":"2020"},{"content":"这篇文站整理下自己经常使用的 alfred workflow\nTerminalFinder 可以快速在终端和finder直接切换，比如在iterm中打开当前finder的目录\nalfred-jetbrains 快速打开 jetbrains 系列 IDE 的项目\nYoudaoTranslate 有道词典翻译\n","id":11,"section":"posts","summary":"这篇文站整理下自己经常使用的 alfred workflow TerminalFinder 可以快速在终端和finder直接切换，比如在iterm中打开当前finder的目录 alfred-jetbrains 快速打开 jetbrains 系列 IDE 的项目","tags":["alfred"],"title":"alfred workflow 推荐","uri":"https://wangtingkui.github.io/2020/05/plugin-recommend/","year":"2020"},{"content":"oh-my-zsh为我们提供了丰富的插件可以极高的提升我们的使用效率。插件分为两类，一类是内建插件， 这种插件不需要我们单独下载，只需要在.zshrc配置文件中开启即可使用，另外一类是自定义插件，我们需要将这类插件下载到~/.oh-my-zsh/custom/plugins目录中，然后再配置使用\n我们使用插件的时候要按需启用，启用过多的插件会导致shell的启动很慢\n内建插件 内建插件的使用很简单，只需要在~/.zshrc中开启即可\n# .zshrc 文件 # Which plugins would you like to load? # Standard plugins can be found in ~/.oh-my-zsh/plugins/* # Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/ # Example format: plugins=(rails git textmate ruby lighthouse) # Add wisely, as too many plugins slow down shell startup. plugins=(git ruby) 这里就列出一些自己常用的插件\n   插件名 描述 截图     git 显示git分支，改动状态等，还自带了很多git命令的缩写    urltools 提供urlencode 和 urldecode功能     自定义插件 自定义插件需要你手动将插件下载到~/.oh-my-zsh/custom/plugins中，然后再启用\n一些推荐的自定义插件\n   插件名 描述 地址 截图     zsh-autosuggestions 自动提示 https://github.com/zsh-users/zsh-autosuggestions    zsh-syntax-highlighting 命令行代码高亮 https://github.com/zsh-users/zsh-syntax-highlighting     ","id":12,"section":"posts","summary":"oh-my-zsh为我们提供了丰富的插件可以极高的提升我们的使用效率。插件分为两类，一类是内建插件， 这种插件不需要我们单独下载，只需要在.z","tags":["zsh","oh-my-zsh"],"title":"使用zsh插件","uri":"https://wangtingkui.github.io/2020/05/plugin/","year":"2020"},{"content":"viper 是一个 go 的配置解决方案，它支持多种多样的配置文件，也支持从配置系统读取配置，比如 etcd。它还可以监视配置文件的变动，实时的载入最新的配置。\n配置优先级 viper 可以从环境变量，配置文件等地方读取配置，甚至可以手动的在运行时设置值，那么 viper 读取配置的优先级是什么呢？根据官网，viper 读取的值得优先级如下\n 通过 Set 设置的值 从命令行选项读取的值 环境变量的值 配置文件的值 key/value store 默认值  快速上手 一个使用 viper 的基本示例如下，基本上完成一个应用也就使用这些功能\n# myconfig.yaml name: xiaok age: 28 sex: male book: - php - java - c other: other_value package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/spf13/viper\u0026#34; ) func main() { viper.AddConfigPath(\u0026#34;.\u0026#34;) // viper 不会帮我们设置任何默认路径，我们需要至少添加一个寻找配置文件的路径 \tviper.SetConfigName(\u0026#34;myconfig\u0026#34;) // 设置配置文件名称 \tviper.SetConfigType(\u0026#34;yaml\u0026#34;) // 如果配置文件没有后缀的话，这个值必须设置  err := viper.ReadInConfig() if err != nil { panic(fmt.Sprintf(\u0026#34;Read config file err: %v\u0026#34;, err)) } // 读取 \tname := viper.GetString(\u0026#34;name\u0026#34;) fmt.Println(name) age := viper.GetInt(\u0026#34;age\u0026#34;) fmt.Println(age) books := viper.GetStringSlice(\u0026#34;book\u0026#34;) fmt.Println(books) viper.SetDefault(\u0026#34;test_default\u0026#34;, \u0026#34;default_value\u0026#34;) // 设置默认值 \tdefaultv := viper.GetString(\u0026#34;test_default\u0026#34;) fmt.Println(defaultv) viper.RegisterAlias(\u0026#34;alias_of_age\u0026#34;, \u0026#34;age\u0026#34;) // 设置配置key别名 \tfmt.Println(viper.GetInt(\u0026#34;alias_of_age\u0026#34;)) viper.Set(\u0026#34;name\u0026#34;, \u0026#34;wudixiaok\u0026#34;) // 运行时设置配置值 \tfmt.Println(viper.GetString(\u0026#34;name\u0026#34;)) // 如果值得类型比较复杂，可以先读取出来，然后再断言 \tv := viper.Get(\u0026#34;other\u0026#34;) realvalue := v.(string) fmt.Println(realvalue) } # 输出 xiaok 28 [php java c] default_value 28 wudixiaok other_value 其他高级功能 viper 还支持各种其他的高级功能，如果想要了解，可以到官网去看看\n","id":13,"section":"posts","summary":"viper 是一个 go 的配置解决方案，它支持多种多样的配置文件，也支持从配置系统读取配置，比如 etcd。它还可以监视配置文件的变动，实时的载入最新的配置","tags":["go"],"title":"使用 viper 处理项目配置","uri":"https://wangtingkui.github.io/2020/05/viper/","year":"2020"},{"content":"当前，go 本身并没有良好的错误处理机制，一个比较常见错误处理方式如下：\nif err != nil { return err } 然后层层传递，最终将错误传递到最上层，这里面存在着两个问题：\n 没有错误发生时的上下文信息（或者叫堆栈信息） 在层层的错误传递过程中，有可能已经将原始错误转化，丢失了最原始的 error  当前，比较优雅的方式是使用 github.com/pkg/errors 这个包来进行错误处理，官方文档\nQUICK START 一个基本的使用如下：\npackage main import ( e \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/pkg/errors\u0026#34; ) func main() { oldErr := e.New(\u0026#34;我是底层error\u0026#34;) // 添加错误信息和堆栈信息，生成一个新的 error \twrappedErr := errors.Wrap(oldErr, \u0026#34;我是封装error\u0026#34;) // 输出错误信息 \tfmt.Printf(\u0026#34;%v\\n\u0026#34;, wrappedErr) fmt.Println(\u0026#34;===============================\u0026#34;) // 输出错误信息和堆栈信息 \tfmt.Printf(\u0026#34;%+v\\n\u0026#34;, wrappedErr) fmt.Println(\u0026#34;===============================\u0026#34;) // 获取底层错误 \terr := errors.Cause(wrappedErr) fmt.Println(err) } 我们也可以使用errors.WithMessage和errors.WithStack单独添加错误信息和堆栈信息\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/pkg/errors\u0026#34; ) func func1() { e := errors.New(\u0026#34;make a error by errors.New\u0026#34;) e = errors.WithMessage(e, \u0026#34;add a message\u0026#34;) e = errors.WithMessage(e, \u0026#34;add another message\u0026#34;) e = errors.WithStack(e) fmt.Printf(\u0026#34;%+v\u0026#34;, e) } func test() { func1() } func main() { test() } 正常的使用方式  在错误的发生点使用errors.New生成错误，或者使用errors.Wrap封装错误，这时候会纪录堆栈信息，在之后就不需要在添加堆栈信息了 如果需要对错误添加错误信息，使用errors.WithMessage方法 顶层使用errors.Cause获取原始错误信息，使用%+v纪录整条链路的错误信息和堆栈信息  ","id":14,"section":"posts","summary":"当前，go 本身并没有良好的错误处理机制，一个比较常见错误处理方式如下： if err != nil { return err } 然后层层传递，最终将错误传递到最上层，这里面存在着两个","tags":["go"],"title":"使用 pkg/errors 进行错误处理","uri":"https://wangtingkui.github.io/2020/04/errors/","year":"2020"},{"content":"markdown 因为简洁的语法非常受到写文章的人的喜爱，但是某些情况下 markdown 也有不足，比如我们想展示一些特殊的样式或者格式的时候，往往需要直接书写 html 代码，这就和 markdown 简洁的初衷相违背了，hugo 提供了shortcode的功能来弥补了 markdown 的这个不足。shortcode 本质上是一些模板，我们可以使用定义好的指令来引用这些模板，相当于书写了一段html在文章中，更多的说明可以查看官网，接下来我们来看看怎么使用 shortcode\n简单使用 使用 shortcode 的语法是 {{% shortcodename parameters %}}，其中：\n shortcodename 是 shortcode 的名字 parameters 是参数列表，如果有多个参数，使用空格分隔，如果某个参数中有空格，需要用双引号把这个参数包起来 % 是定界符，也有使用\u0026lt;和\u0026gt;做定界符的，{{\u0026lt; shortcodename parameters \u0026gt;}}  参数有两种传递方式，基于名字的({{% shortcodename name1=value1 name2=value2 %}}))和基于位置的({{% shortcodename value1 value2 %}})，使用哪种方式取决于 shortcode 自己模板的定义。\n有的 shortcode 使用的时候要求闭合，类似 html 标签，比如 {{\u0026lt; highlight go \u0026gt;}} A bunch of code here {{\u0026lt; /highlight \u0026gt;}}\n常用的内置 shortcode\n   shortcodename 说明 usage     ref 使用绝对路径引用博客内其他文章 {{% ref \u0026quot;blog/other_article.md\u0026quot; %}}   relref 使用相对路径引用博客内其他文章 {{% relref \u0026quot;blog/other_article.md\u0026quot; %}}    ","id":15,"section":"posts","summary":"markdown 因为简洁的语法非常受到写文章的人的喜爱，但是某些情况下 markdown 也有不足，比如我们想展示一些特殊的样式或者格式的时候，往往需要直接书写 html 代码，这就","tags":["hugo"],"title":"在hugo中使用shortcode","uri":"https://wangtingkui.github.io/2020/04/shortcodes/","year":"2020"},{"content":"本篇文章主要讲解下 go 的 time 包如何使用。go 中 time 的使用主要分为以下三个方面：\n 时间点的表示及其操作，以及时间点的格式化展示 时间段的表示及其操作 定时器的操作  本文只是列举比较常用的场景，更多的细节还是要参考官方文档\n时间点 在 go 中，时间点使用 time.Time 来表示，这是一个基于纳秒精度的时间表示，我们还是通过一些例子来来学习\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { // 获取时间 \tnow := time.Now() // 获取当前时间点对象 \tt := time.Unix(1586708379, 0) // 从指定时间戳实例化Time对象，第二个参数可以指定纳秒的精度  s, _ := time.Parse(\u0026#34;2006-01-02 03:04:05\u0026#34;, time.Now().Format(\u0026#34;2006-01-02 03:04:05\u0026#34;)) // 从时间字符串解析 \tfmt.Println(now, t, s) // 分解时间中的时间元素 \tyear := t.Year() // 获取年 \tmonth := t.Month() // 获取月份 \tday := t.Day() // 获取日 \thour := t.Hour() // 获取小时 \tminute := t.Minute() // 获取分钟 \tsecond := t.Second() // 获取秒数 \tt.Unix() // 转换成时间戳 \tt.UnixNano() // 转换成纳秒时间戳 \tfmt.Println(year, month, day, hour, minute, second) // 时间操作 \tt.Add(time.Second * 10) // 添加10s \ttime.Now().Sub(t) // 计算时间差值，结果是个时间段 \tt.Equal(time.Now()) // 比较两个时间是否相等，而且支持跨时区比较 \tt.Before(time.Now()) // 比较某个时间是否在另一个时间之前 \tt.After(time.Now()) // 比较某个时间是否在另一个时间之后  // 格式化展示 \tfmt.Println(t.Format(\u0026#34;2006-01-02 03:04:05\u0026#34;)) } 在 go 中，时间的格式化非常特别，是通过一些指定的数字来进行格式化的，这些数字也非常有记忆点，口诀是`2006 1 2 3 4 5`，也就是2006年1月2日下午3点4分5秒，不同的格式化就是通过摆弄这些数字来得到的 时间段 在 go 中，时间段是使用 time.Duration 来表示的，也是纳秒精度的一个数值，同时 go 也定义了一系列常用的时间精度，比如秒，小时等，看 go 中的源码很简单就能看明白：\n// go 源码 type Duration int64 const ( Nanosecond Duration = 1 Microsecond = 1000 * Nanosecond Millisecond = 1000 * Microsecond Second = 1000 * Millisecond Minute = 60 * Second Hour = 60 * Minute ) package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { d := 10 * time.Second hour := d.Hours() // 转换成小时 \tminite := d.Minutes() // 转换成分钟 \tsecond := d.Seconds() // 转换成秒 \tnano := d.Nanoseconds() // 转换成纳秒 \tfmt.Println(hour, minite, second, nano) } 定时器 定时器的本质是一个 Time 类型的 channel，会以我们指定的时间间隔在 channel 中产生值\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;time\u0026quot; ) func main() { ticker := time.Tick(time.Second) // 定义一个1秒间隔的定时器 for i := range ticker { fmt.Println(i) // 每秒都会执行的任务 } } ","id":16,"section":"posts","summary":"本篇文章主要讲解下 go 的 time 包如何使用。go 中 time 的使用主要分为以下三个方面： 时间点的表示及其操作，以及时间点的格式化展示 时间段的表示及其操作 定时","tags":["go"],"title":"Go标准库（time）- 使用","uri":"https://wangtingkui.github.io/2020/04/time/","year":"2020"},{"content":"log 标准包实现了一个简单的日志功能，本片文章主要写下 log 标准包的基本使用\n实例化 logger 进行日志记录 首先看一个最简单的 demo：\npackage main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func main() { logger := log.New(os.Stdout, \u0026#34;我是自定义日志前缀：\u0026#34;, log.LstdFlags) logger.Println(\u0026#34;I\u0026#39;m print call\u0026#34;) } // 我是自定义日志前缀：2020/03/29 20:45:43 I\u0026#39;m print call  log 包最终输出到哪里和包本身无关，取决于 io.Writer（第一个参数） 对应的实际对象底层传递的是什么。\nlog 可以支持我们指定每条日志的前缀（第二个参数）和一些固定的标记（第三个参数）\nlogger 有Print、Fatal、Panic三个系列的方法，区别如下\n Print只记录日志 Fatal记录日志后会调用os.Exit(1)推出应用 Panic记录日志后会调用Panic  每个系列也都提供了三种调用方式，比如Print系列有以下三种方式：\n Print输出给定的信息 Println输出给定的信息并且在后面追加一个换行 Printf支持使用格式化参数  使用辅助方法进行日志记录 log 包还提供了一些快捷方法，可以直接通过包的方法调用，比如\npackage main import ( \u0026#34;log\u0026#34; ) func main() { log.Println(\u0026#34;hahahha\u0026#34;) } // 2020/03/29 20:47:42 hahahha  它其实是在包内生成了一个输出到 stdout 的 logger，方便我们使用而已\n","id":17,"section":"posts","summary":"log 标准包实现了一个简单的日志功能，本片文章主要写下 log 标准包的基本使用 实例化 logger 进行日志记录 首先看一个最简单的 demo： package main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func main() { logger :=","tags":["go"],"title":"Go标准库（log）- 使用","uri":"https://wangtingkui.github.io/2020/03/log/","year":"2020"},{"content":"本篇文章是写一下我怎么进行php的多版本管理，利用的是phpbrew这个工具\n phpbrew github 地址  phpbrew安装 第一步 首先需要下载二进制文件\ncurl -L -O https://github.com/phpbrew/phpbrew/releases/latest/download/phpbrew.phar chmod +x phpbrew.phar # Move the file to some directory within your $PATH sudo mv phpbrew.phar /usr/local/bin/phpbrew 第二步 安装好二进制文件之后，phpbrew还需要一点简单的配置才能使用\n# 初始化phpbrew shell脚本 phpbrew init # 在shell配置文件（~/.bashrc 或者 ~/.zshrc）中添加 echo \u0026quot;[[ -e ~/.phpbrew/bashrc ]] \u0026amp;\u0026amp; source ~/.phpbrew/bashrc\u0026quot; \u0026gt;\u0026gt; ~/.zshrc # 重新加载shell配置文件 source ~/.zshrc 第三步 设置用于查找库文件的默认前缀，可选值有 macports，homebrew，debian，ubuntu 或是自定义路径。\n对于使用homebrew的用户，可以设置phpbrew lookup-prefix homebrew\nphpbrew命令简单使用 # 查看phpbrew版本 phpbrew --version # 查看可以安装的版本 phpbrew know # 列出本地已经安装的版本 phpbrew list # 临时切换版本 phpbrew use 7.0.1 # 设置默认php版本 phpbrew switch 7.0.1 # 关闭phpbrew phpbrew off # 编辑当前版本的php.ini文件 phpbrew config # 编辑当前版本的fpm文件 phpbrew fpm config # 测试当前版本fpm配置 phpbrew fpm test # 进行当前版本的fpm操作 phpbrew fpm [start|restart|stop] # 升级phpbrew phpbrew self-update 编译安装指定版本php 之所以单独将安装命令拿出来写，是因为相对而言，phpbrew的安装命令比较复杂，phpbrew提出了一个Variants的概念，将php编译的复杂的配置选项屏蔽起来\n你只需简单地指定某个 Variant 即可，phpbrew 会自动在配置过程中检测引用目录、编译选项等。\nPHPBrew 提供默认的 Variants ，以及一些虚拟 Variants。 「Default Variants」包含绝大多数公共 Variants； 「Virtual Variants」可包含多个 Variants，使用一个虚拟 Variants 即可一次性启用多个 Variants。\n可以使用phpbrew variants查看都有哪些variants\n➜ ~ phpbrew variants Variants: all, apxs2, bcmath, bz2, calendar, cgi, cli, ctype, curl, dba, debug, dom, dtrace, editline, embed, exif, fileinfo, filter, fpm, ftp, gcov, gd, gettext, gmp, hash, iconv, imap, inifile, inline, intl, ipc, ipv6, json, kerberos, ldap, libgcc, mbregex, mbstring, mcrypt, mhash, mysql, opcache, openssl, pcntl, pcre, pdo, pear, pgsql, phar, phpdbg, posix, readline, session, soap, sockets, sodium, sqlite, static, tidy, tokenizer, wddx, xml, xmlrpc, zip, zlib, zts Virtual variants: dbs: sqlite, mysql, pgsql, pdo mb: mbstring, mbregex neutral: small: bz2, cli, dom, filter, ipc, json, mbregex, mbstring, pcre, phar, posix, readline, xml, curl, openssl default: bcmath, bz2, calendar, cli, ctype, dom, fileinfo, filter, ipc, json, mbregex, mbstring, mhash, pcntl, pcre, pdo, pear, phar, posix, readline, sockets, tokenizer, xml, curl, openssl, zip everything: dba, ipv6, dom, calendar, wddx, static, inifile, inline, cli, ftp, filter, gcov, zts, json, hash, exif, mbstring, mbregex, libgcc, pdo, posix, embed, sockets, debug, phpdbg, zip, bcmath, fileinfo, ctype, cgi, soap, pcntl, phar, session, tokenizer, opcache, imap, ldap, tidy, kerberos, xmlrpc, fpm, dtrace, pcre, mhash, mcrypt, zlib, curl, readline, editline, gd, intl, sodium, openssl, mysql, sqlite, pgsql, xml, gettext, iconv, bz2, ipc, gmp, pear Using variants to build PHP: phpbrew install php-5.3.10 +default phpbrew install php-5.3.10 +mysql +pdo phpbrew install php-5.3.10 +mysql +pdo +apxs2 phpbrew install php-5.3.10 +mysql +pdo +apxs2=/usr/bin/apxs2 在mac下安装，我们几乎必然会遇到某些依赖的头文件找不到的问题，遇到这种问题，我们可以先手动下载依赖库，然后在使用Variants的时候明确指定下依赖库的路径即可\n比如遇到下面的情况，明显是找不到openssl的依赖库，所以我们可以执行下面的操作\n# 先手动安装openssl brew install openssl # 明确指定openssl的位置 phpbrew install 7.0.13 +all +openssl=/usr/local/opt/openssl 如果有些配置没有被包含到variants中，我们可以在安装命令的末尾添加原始的编译选项-- 原始选项，注意--是必不可少的，他是variants和原始编译选项的分隔符\n我安装的一个demo\nphpbrew install 7.0.33 +default +mb +dbs +fpm -pgsql +zlib=/usr/local/opt/zlib mac安装过程中经常会缺少的库报错集合 # error configure: error: utf8_mime2text() has new signature, but U8T_CANONICAL is missing. This should not happen. Check config.log for additional information. #fix brew install imap-uw ","id":18,"section":"posts","summary":"本篇文章是写一下我怎么进行php的多版本管理，利用的是phpbrew这个工具 phpbrew github 地址 phpbrew安装 第一步 首先需要下载二进制文件 curl -L -O https://github.com/phpbrew/phpbrew/releases/latest/download/phpbrew.phar chmod","tags":["php"],"title":"php多版本管理","uri":"https://wangtingkui.github.io/2020/01/php-multi-version/","year":"2020"},{"content":"go 的 os 包提供了与基础的与操作系统无关的文件操作，包括创建、删除、读写等。同时为了更便捷的操作和性能上的提升，go在 io/ioutil 、bufio 等包中也提供了一些常用的方法供开发者使用\n本文只列出了一些常用的方法，更多的操作可以参考：https://colobu.com/2016/10/12/go-file-operations\n使用 os 包进行文件操作  打开文件\n package main import ( \u0026#34;os\u0026#34; ) func main() { var ( file *os.File err error ) // 以只读方式打开一个文件 \tfile, err = os.Open(\u0026#34;a.txt\u0026#34;) if err != nil { panic(err) } _ = file.Close() // 以指定的模式打开文件，这个方法更具有通用性 \t// 一般情况下我们应该尽量使用 os.Open 和 os.Create 方法而不是这个方法 \tfile, err = os.OpenFile(\u0026#34;a.txt\u0026#34;, os.O_APPEND, 0666) if err != nil { panic(err) } _ = file.Close() }  创建文件\n package main import ( \u0026#34;os\u0026#34; ) func main() { // 创建一个空文件 \t// 看源码就可以发现它其实就是 OpenFile(name, O_RDWR|O_CREATE|O_TRUNC, 0666) 的快捷方式 \tfile, err := os.Create(\u0026#34;create.txt\u0026#34;) if err != nil { panic(err) } _ = file.Close() // 使用给定的unix文件描述符和名称创建文件，一般不使用 \tfile = os.NewFile(3, \u0026#34;haha.txt\u0026#34;) _ = file.Close() }  删除文件\n package main import ( \u0026#34;os\u0026#34; ) func main() { err := os.Remove(\u0026#34;create.txt\u0026#34;) if err != nil { panic(err) } }  重命名和移动文件\n package main import ( \u0026#34;os\u0026#34; ) func main() { err := os.Rename(\u0026#34;a.txt\u0026#34;, \u0026#34;b.txt\u0026#34;) if err != nil { panic(err) } }  清空文件\n package main import ( \u0026#34;os\u0026#34; ) func main() { // 第二个参数是要保留的字节数，如果传入0，就是清空整个文件 \terr := os.Truncate(\u0026#34;b.txt\u0026#34;, 2) if err != nil { panic(err) } }  获取文件信息\n package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) var ( fileInfo os.FileInfo err error ) func main() { fileInfo, err = os.Stat(\u0026#34;b.txt\u0026#34;) if err != nil { panic(err) } fmt.Println(\u0026#34;File name:\u0026#34;, fileInfo.Name()) fmt.Println(\u0026#34;Size in bytes:\u0026#34;, fileInfo.Size()) fmt.Println(\u0026#34;Permissions:\u0026#34;, fileInfo.Mode()) fmt.Println(\u0026#34;Last modified:\u0026#34;, fileInfo.ModTime()) fmt.Println(\u0026#34;Is Directory: \u0026#34;, fileInfo.IsDir()) fmt.Printf(\u0026#34;System interface type: %T\\n\u0026#34;, fileInfo.Sys()) fmt.Printf(\u0026#34;System info: %+v\\n\\n\u0026#34;, fileInfo.Sys()) }  文件读取\n package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { file, err := os.Open(\u0026#34;b.txt\u0026#34;) if err != nil { panic(err) } buf := make([]byte, 10) for { l, err := file.Read(buf) if l \u0026gt; 0 { fmt.Println(string(buf[:l])) } if err != nil { break } } }  写文件\n package main import ( \u0026#34;os\u0026#34; ) func main() { file, err := os.Create(\u0026#34;newfile.txt\u0026#34;) if err != nil { panic(err) } defer file.Close() file.Write([]byte(\u0026#34;fuck1\u0026#34;)) file.WriteString(\u0026#34;fuck2\u0026#34;) } 使用 bufio 操作文件  按行读取文件\n package main import ( \u0026#34;bufio\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { file, err := os.Open(\u0026#34;b.txt\u0026#34;) if err != nil { panic(err) } defer file.Close() // 通过 bufio.Reader 读取行 \t// 默认 buffer 是4096 \treader := bufio.NewReader(file) for { // 读取文件的一行，默认用 \\r\\n 或者 \\n 分隔，读取出来的行是不包含分隔符的 \t// 如果文件的行太长，h超过了 bufio.Reader 内部的 buffer， 会将第二个返回参数 isPrefix 设置为 true \tbuf, _, err := reader.ReadLine() if err != nil { break } fmt.Println(string(buf)) } // 通过bufio.Scanner 读取行 \tfile.Seek(0, 0) scanner := bufio.NewScanner(file) // scanner.Split() ，可以通过这个函数设置自定义的分隔方式，默认是换行 \tfor scanner.Scan() { fmt.Println(scanner.Text()) } } 使用 io/ioutil 进行文件操作 ","id":19,"section":"posts","summary":"go 的 os 包提供了与基础的与操作系统无关的文件操作，包括创建、删除、读写等。同时为了更便捷的操作和性能上的提升，go在 io/ioutil 、bufio 等包中也提供","tags":["go"],"title":"Go进行文件操作","uri":"https://wangtingkui.github.io/2020/01/go-file-operation/","year":"2020"},{"content":"net/http 包为我们提供了对 http 协议的处理，包含了客户端和服务端两大部分的实现\n版本  go1.12  主要结构体 几乎任何语言中的http包都是围绕客户端，服务端，请求和响应这4个对象展开的，go 也不例外。本篇主要是讲解包的使用，所以还是通过例子来说明\n客户端 快速入门 http 客户端基本的使用流程：\n 构造请求 构造客户端 使用客户端发送请求获取响应 使用响应  下面用一个最简单的例子来展示下上面的流程：\nfunc main() { // 创建一个请求 \treq, err := http.NewRequest(\u0026#34;GET\u0026#34;, \u0026#34;http://www.baidu.com\u0026#34;, nil) if err != nil { panic(err) } // 创建一个客户端 \tclient := http.Client{} // 使用客户端发送请求 \tresp, err := client.Do(req) if err != nil { panic(err) } // 使用响应 \tdefer resp.Body.Close() if ret, err := ioutil.ReadAll(resp.Body); err != nil { panic(err) } else { fmt.Println(string(ret)) } } 当我们没有特殊需求，只是想要简单的发送一个 get 或者是 post 请求的时候，上面的代码明显有些冗长，还是同其他的包一样，对这种简单使用，go 的官方包通常会为我们提供一些\u0026quot;快捷方法\u0026rdquo;（其实就是在包内生成一些默认对象，再导出一些方法，使用这些默认对象而已，从而节省了我们构造对象的过程）。\nfunc main() { // 创建一个请求 \tif resp, err := http.Get(\u0026#34;http://www.baidu.com\u0026#34;); err != nil { panic(err) } else { defer resp.Body.Close() body, _ := ioutil.ReadAll(resp.Body) fmt.Println(string(body)) } } 像这样的“快捷方法”还有Post,PostForm,Head\n精细化控制各项请求参数 当我们想要控制比如超时时间、重定向规则等属性的时候，我们就必须手动的去构造请求和客户端，设置我们的参数，从而达到精细控制的目的，下面让我们看以下如何设置常用的参数\n设置超时时间 // 超时控制需要在客户端中设置 client := http.Client{ Transport: \u0026amp;http.Transport{ DialContext: (\u0026amp;net.Dialer{ Timeout: time.Second, // 连接超时  }).DialContext, }, CheckRedirect: nil, // 用来判断重定向  Jar: nil, // 用来设置cookie  Timeout: 4 * time.Second, // 从发出请求到读取完响应的整体时间 } 设置header req := http.NewRequest(\u0026#34;GET\u0026#34;, \u0026#34;http://www.baidu.com\u0026#34;, nil) req.Header.Add(\u0026#34;Test-Header1\u0026#34;, \u0026#34;header1\u0026#34;) req.Header.Add(\u0026#34;Test-Header2\u0026#34;, \u0026#34;header2\u0026#34;) 服务端 快速入门 创建一个服务端的基本步骤：\n 创建一个路由器 设置路由 启动server监听  // 同样的，官方包也为我们提供了快速创建服务端的“快捷方式”\nfunc main() { http.HandleFunc(\u0026#34;/ping\u0026#34;, func(w http.ResponseWriter, req *http.Request) { w.Write([]byte(\u0026#34;pong\u0026#34;)) }) http.ListenAndServe(\u0026#34;:8888\u0026#34;, nil) } ","id":20,"section":"posts","summary":"net/http 包为我们提供了对 http 协议的处理，包含了客户端和服务端两大部分的实现 版本 go1.12 主要结构体 几乎任何语言中的http包都是围绕客户端，服务端，请求和响","tags":["go"],"title":"Go标准库（net/http）- 使用","uri":"https://wangtingkui.github.io/2019/12/net-http/","year":"2019"},{"content":"net/url包是官方为我们提供的处理 url 链接的库，基本能覆盖我们大多数场景下的使用\nurl 结构 在学习使用这个库之前，我们先来了解下 url 的标准结构：scheme://[userinfo@]host/path[?query][#fragment]，如果 scheme 之后不是以斜线开头的，那么结构被认为是 scheme:opaque[?query][#fragment]，也就是用户信息、域名和路径部分是不透明的，可以认为是被加密或者被编码过的\n环境  go1.12  包中的基本结构体 这个包中有3个比较基本的结构体：\n URL：代表一个被解析的url UserInfo：代表 url 中的用户信息部分 Values：存放 query 参数或者 form 参数  type URL struct { Scheme string Opaque string // encoded opaque data \tUser *Userinfo // username and password information \tHost string // host or host:port \tPath string // path (relative paths may omit leading slash) \tRawPath string // encoded path hint (see EscapedPath method) \tForceQuery bool // append a query (\u0026#39;?\u0026#39;) even if RawQuery is empty \tRawQuery string // encoded query values, without \u0026#39;?\u0026#39; \tFragment string // fragment for references, without \u0026#39;#\u0026#39; } type Userinfo struct { username string password string passwordSet bool } type Values map[string][]string 基本使用 编码和解码操作 func main() { var ( rowUrl = \u0026#34;http://www.baidu.com?q=我 曹#123\u0026#34; escapedUrl string unescapedUrl string ) // 可以保证安全的放在query中 \tescapedUrl = url.QueryEscape(rowUrl) unescapedUrl, _ = url.QueryUnescape(escapedUrl) fmt.Println(escapedUrl) fmt.Println(unescapedUrl) // 可以保证安全的放在path段中 \tescapedUrl = url.PathEscape(rowUrl) unescapedUrl, _ = url.PathUnescape(escapedUrl) fmt.Println(escapedUrl) fmt.Println(unescapedUrl) } // http%3A%2F%2Fwww.baidu.com%3Fq%3D%E6%88%91+%E6%9B%B9%23123 // http://www.baidu.com?q=我 曹#123 // http:%2F%2Fwww.baidu.com%3Fq=%E6%88%91%20%E6%9B%B9%23123 // http://www.baidu.com?q=我 曹#123  解析 url 链接生成 URL 结构体 // 从指定的url解析生成URL对象 func Parse(rawurl string) (url *URL, err error) // 这个方法也是解析 url， 和 Parse 不同的是，这个方法假定接受的原始 url 是从 http 请求拿来的，一定是绝对路径，并且也没有 fragment 后缀(浏览器在发送请求的时候会去掉) func ParseRequestURI(rawurl string) (url *URL, err error) URL 其他常用方法 func main() { rowUrl := \u0026#34;http://www.baidu.com/fuck?a=a\u0026amp;b=b\u0026amp;c=c#123\u0026#34; url, _ := url.Parse(rowUrl) // 是否是绝对路径（scheme是否为空） \tfmt.Println(url.IsAbs()) // 返回拆分后的query \tfmt.Println(url.Query()) // 返回域名之后的部分 \tfmt.Println(url.RequestURI()) } // true // map[a:[a] b:[b] c:[c]] // /fuck?a=a\u0026amp;b=b\u0026amp;c=c Values 常用方法 func main() { rowUrl := \u0026#34;http://www.baidu.com/fuck?a=a\u0026amp;b=b\u0026amp;c=c#123\u0026#34; url, _ := url.Parse(rowUrl) values := url.Query() fmt.Println(values) // 添加一个元素 \tvalues.Add(\u0026#34;d\u0026#34;, \u0026#34;d\u0026#34;) fmt.Println(values) // 删除一个元素 \tvalues.Del(\u0026#34;a\u0026#34;) fmt.Println(values) // 获取一个元素 \tfmt.Println(values.Get(\u0026#34;b\u0026#34;)) // 设置一个元素 \tvalues.Set(\u0026#34;c\u0026#34;, \u0026#34;ccc\u0026#34;) fmt.Println(values) values.Set(\u0026#34;name\u0026#34;, \u0026#34;王\u0026#34;) // 编码成 url query 格式 \tfmt.Println(values.Encode()) } // map[a:[a] b:[b] c:[c]] // map[a:[a] b:[b] c:[c] d:[d]] // map[b:[b] c:[c] d:[d]] // b // map[b:[b] c:[ccc] d:[d]] // b=b\u0026amp;c=ccc\u0026amp;d=d\u0026amp;name=%E7%8E%8B ","id":21,"section":"posts","summary":"net/url包是官方为我们提供的处理 url 链接的库，基本能覆盖我们大多数场景下的使用 url 结构 在学习使用这个库之前，我们先来了解下 url 的标准结构：s","tags":["go"],"title":"Go标准库（net/url）- 使用","uri":"https://wangtingkui.github.io/2019/12/net-url/","year":"2019"},{"content":"zap 是一个高性能的第三方日志类库，本篇主要说明下如何使用 zap\n版本 本篇基于的 zap 版本是 v1.10.0\n使用 基本概念 在使用 zap 之前，我们还是先了解下 zap 里面的一些基本概念，方便在我们阅读 demo 或者写代码的时候能大体的感知到我们在用什么，为什么这样用。为了不产生翻译上的歧义，书写过程中涉及到的概念会用 zap 源码中的命名\n Logger\n 这是 zap 暴露给我们类型，正常情况下，我们也是通过 Logger 这个结构体的方法来记录日志的\n Config\n 这个是 zap 提供给我们的 Logger 的配置，我们可以按需配置，然后通过 Build 方法来构造出我们想要的 Logger，是典型的的构造者模式\n Field\n 除了日志级别、日志时间、日志信息等这些基本的通用字段之外，我们在记录日志的时候通常会想记录一些额外的字段（用来记录打日志时的上下文），这些字段在 zap 中需要封装成 Field 类型\n Core\n Logger 是一个结构体，为我们暴露了使用日志的方法，而 Core 是一个接口，它被包含在 Logger 中，用来真正提供日志格式化和输出功能，这样的实现使日志记录器的使用和输出实现了高度解耦。我们可以实现自己的 Core 从而达到不同的输出的目的\n Encoder\n Encoder 同样是一个接口，刚才说到 Core 是实现具体输出行为的核心，而 Encoder 是 Core 中真正进行日志信息和字段格式化的编码器，它把我们输入的各种日志信息经过处理得到字节切片。从而可以记录在各种存储载体中。zap 对于 Encoder 自带了两个实现，jsonEncoder 和 consoleEncoder\n EncoderConfig\n 这个就很好理解了，就是我们 Encoder 的配置，由于不同的 Encoder 实现不一样，所以如果是我们自己实现的 Encoder，完全可以实现自己的 EncoderConfig，zap 中的 EncoderConfig 自然也是为了 jsonEncoder 和 consoleEncoder 服务的。\nLogger 快速入门 了解了 zap 中的一些基础概念，让我们先来搞一个小 demo 感受一下\n代码：\nfunc main() { // 实例化一个 EncoderConfig \tencoderCfg := zapcore.EncoderConfig{ MessageKey: \u0026#34;msg\u0026#34;, // 序列化成json时在输出中的key \tLevelKey: \u0026#34;level\u0026#34;, NameKey: \u0026#34;logger\u0026#34;, EncodeLevel: zapcore.LowercaseLevelEncoder, // 日志级别字段的值序列化方式，这里使用了zap自带的小写格式编码 \tEncodeTime: zapcore.ISO8601TimeEncoder, // 时间字段的值序列化方式，这里使用了自带的ISO8601格式编码 \tEncodeDuration: zapcore.StringDurationEncoder, // 时间段类型的值序列化方式，这里使用自带的字符串格式 \t} // 用刚才 EncoderConfig 实例化一个 jsonEncoder，也就是输出成json格式 \tjsonEncoder := zapcore.NewJSONEncoder(encoderCfg) // 实例化一个 Core，使用 jsonEncoder，将 InfoLevel 级别以上（包含 InfoLevel）的日志输出到标准输出中 \tcore := zapcore.NewCore(jsonEncoder, os.Stdout, zapcore.InfoLevel) // 用 Core 实例化一个 Logger \tlogger := zap.New(core) logger.Debug(\u0026#34;debug level log\u0026#34;, zap.String(\u0026#34;k\u0026#34;, \u0026#34;v\u0026#34;)) logger.Info(\u0026#34;info level log\u0026#34;, zap.Bool(\u0026#34;k\u0026#34;, false)) logger.Warn(\u0026#34;warn level log\u0026#34;, zap.Time(\u0026#34;t\u0026#34;, time.Now())) logger.Error(\u0026#34;error level log\u0026#34;, zap.Int(\u0026#34;i\u0026#34;, 9)) } 输出：\n{\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;info level log\u0026#34;,\u0026#34;k\u0026#34;:false} {\u0026#34;level\u0026#34;:\u0026#34;warn\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;warn level log\u0026#34;,\u0026#34;t\u0026#34;:\u0026#34;2019-12-16T23:58:53.324+0800\u0026#34;} {\u0026#34;level\u0026#34;:\u0026#34;error\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;error level log\u0026#34;,\u0026#34;i\u0026#34;:9} 之所以少一条，是应为我们设置了 info 级别以上才输出。\n使用构造方法获取预置 Logger 可以看到上面的整个使用过程，基本上都是围绕着我们最开始提到的基本概念展开的，同时也能明显的感受到，构造一个 Logger 的过程还是复杂的，所以同很多包一样，zap 也为我们提供了几个方便的构造函数，能让我们快速的获取 Logger，基本也能覆盖我们大多数简单的使用场景，分别是zap.NewExample，zap.NewDevelopment和zap.NewProduction，除了这3个，还有一个zap.NewNop，这个相当于一个空 Logger，不做任何操作，所以也不用着重介绍了。下面让我们依次看下前三个。\n zap.NewExample\n func main() { logger := zap.NewExample() logger.Debug(\u0026#34;我是debug信息\u0026#34;, zap.String(\u0026#34;k\u0026#34;, \u0026#34;v\u0026#34;)) logger.Info(\u0026#34;我是info信息\u0026#34;, zap.Bool(\u0026#34;b\u0026#34;, true)) } // {\u0026#34;level\u0026#34;:\u0026#34;debug\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;我是debug信息\u0026#34;,\u0026#34;k\u0026#34;:\u0026#34;v\u0026#34;} // {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;我是info信息\u0026#34;,\u0026#34;b\u0026#34;:true}  可以看到这样用起来就非常方便了，如果我们取看他的源码，会发现其实就是封装了我们上面创建一个 Logger 的过程\n zap.NewDevelopment\n func main() { logger, _ := zap.NewDevelopment() logger.Debug(\u0026#34;我是debug信息\u0026#34;, zap.String(\u0026#34;k\u0026#34;, \u0026#34;v\u0026#34;)) logger.Info(\u0026#34;我是info信息\u0026#34;, zap.Bool(\u0026#34;b\u0026#34;, true)) } // 2019-12-17T11:40:33.606+0800 DEBUG zap/main.go:9 我是debug信息 {\u0026#34;k\u0026#34;: \u0026#34;v\u0026#34;} // 2019-12-17T11:40:33.606+0800 INFO zap/main.go:10 我是info信息 {\u0026#34;b\u0026#34;: true}   zap.NewProduction\n func main() { logger, _ := zap.NewProduction() logger.Debug(\u0026#34;我是debug信息\u0026#34;, zap.String(\u0026#34;k\u0026#34;, \u0026#34;v\u0026#34;)) logger.Info(\u0026#34;我是info信息\u0026#34;, zap.Bool(\u0026#34;b\u0026#34;, true)) } // {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;ts\u0026#34;:1576554152.8352141,\u0026#34;caller\u0026#34;:\u0026#34;zap/main.go:10\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;我是info信息\u0026#34;,\u0026#34;b\u0026#34;:true} 通过配置构造 Logger 上面的几种用法都是我们手动的创建 Logger，我们还可以通过构造 Logger 的 Config，从而来构建 Logger，可以通过 zap.NewDevelopment 的源码学习\n这种方法也能给我们带来比较大的灵活性，能在 Logger 的配置上有更大的自由度\n如果想更加精细的配置 Logger，比如同时使用多个 Core 输出，可以参考本文的 zap 高级配置小节\n使用 SugaredLogger 进行日志记录 即便是 zap 为我们提供了几个预置的 Logger，但是当我们想添加自己的附加字段的时候，需要对每个字段调用对应的封装函数将其包装为 zap.Field 类型，这样做的好处是效率非常高，但是当我们不在乎这一点性能的提升，愿意用一点点性能的损耗来换取编程的方便的时候，可以使用 zap 为我们提供的 SugaredLogger 这个类，名字也非常形象，语法糖，方便我们的编程过程\nSugaredLogger 是对 Logger 的封装，提供了更加方便的api供我们使用，其实就是不必去调用 zap 的一系列函数，将我们的额外字段封装成 Field 类型，在 SugaredLogger 底层会自动帮我们处理\nLogger 和 SugaredLogger 之间的转换也非常简单，我们完全可以在一个项目中根据需求混合使用两种日志记录方式\nfunc main() { logger, _ := zap.NewDevelopment() // 通过 Logger 转换成 SugaredLogger \tsugar := logger.Sugar() sugar.Info(\u0026#34;sugar info message\u0026#34;) sugar.Infof(\u0026#34;sugar info formatted message %s\u0026#34;, \u0026#34;hehe\u0026#34;) sugar.Infow(\u0026#34;sugar info message with extra context\u0026#34;, \u0026#34;key1\u0026#34;, \u0026#34;val1\u0026#34;, \u0026#34;ket2\u0026#34;, true) // 通过 SugaredLogger 转换成 Logger \tlg := sugar.Desugar() lg.Debug(\u0026#34;我是debug信息\u0026#34;, zap.String(\u0026#34;k\u0026#34;, \u0026#34;v\u0026#34;)) lg.Info(\u0026#34;我是info信息\u0026#34;, zap.Bool(\u0026#34;b\u0026#34;, true)) } //2019-12-17T12:08:14.535+0800 INFO zap/main.go:12 sugar info message //2019-12-17T12:08:14.535+0800 INFO zap/main.go:13 sugar info formatted message hehe //2019-12-17T12:08:14.535+0800 INFO zap/main.go:14 sugar info message with extra context {\u0026#34;key1\u0026#34;: \u0026#34;val1\u0026#34;, \u0026#34;ket2\u0026#34;: true} //2019-12-17T12:08:14.535+0800 DEBUG zap/main.go:18 我是debug信息 {\u0026#34;k\u0026#34;: \u0026#34;v\u0026#34;} //2019-12-17T12:08:14.535+0800 INFO zap/main.go:19 我是info信息 {\u0026#34;b\u0026#34;: true}  zap 高级配置 可以参考：https://godoc.org/go.uber.org/zap#pkg-examples\n","id":22,"section":"posts","summary":"zap 是一个高性能的第三方日志类库，本篇主要说明下如何使用 zap 版本 本篇基于的 zap 版本是 v1.10.0 使用 基本概念 在使用 zap 之前，我们还是先了解下 zap 里面的一些基本概","tags":["go"],"title":"go日志库zap使用","uri":"https://wangtingkui.github.io/2019/12/zap/","year":"2019"},{"content":"简介 这个库主要是对文件路径的操作，是比较常用的一个库，由于这个库比较简单，没有什么需要过多的说明，大部分的方法会以实例的形式来展示\n而且要注意的是，path/filepath这个库并不会去判断你指定的路径存不存在，也不会去判断指定的路径是一个文件还是一个目录\n环境 ╰─$ go version go version go1.12.14 darwin/amd64 说明 获取指定路径的目录 filepath.Dir() 代码：\nfunc main() { examples := []string{ \u0026#34;/etc/a.txt\u0026#34;, \u0026#34;/etc/\u0026#34;, \u0026#34;/etc\u0026#34;, \u0026#34;etc/a.txt\u0026#34;, \u0026#34;etc\u0026#34;, \u0026#34;\u0026#34;, } for _, path := range examples { fmt.Println(filepath.Dir(path)) } } 输出：\n╰─$ go run main.go /etc /etc / etc . . 获取指定路径的文件名 filepath.Base() 代码：\nfunc main() { examples := []string{ \u0026#34;/etc/a.txt\u0026#34;, \u0026#34;/etc/\u0026#34;, // 在拆分之前会去除末尾的斜杠，相当于 /etc \t\u0026#34;/etc\u0026#34;, \u0026#34;etc/a.txt\u0026#34;, \u0026#34;etc\u0026#34;, \u0026#34;\u0026#34;, // 如果是空字符串，返回 . \t\u0026#34;/\u0026#34;, // 如果是 / ，返回 / \t} for _, path := range examples { fmt.Println(filepath.Base(path)) } } 输出：\n╰─$ go run main.go a.txt etc etc a.txt etc . / 绝对路径和相对路径相关处理 代码：\nfunc main() { var ( absPath = \u0026#34;/etc/a.txt\u0026#34; relPath = \u0026#34;a.txt\u0026#34; tmpPath string err error ) // 判断是否绝对路径 \tfmt.Println(\u0026#34;absPath is asb path:\u0026#34;, filepath.IsAbs(absPath)) fmt.Println(\u0026#34;relPath is abs path:\u0026#34;, filepath.IsAbs(relPath)) // 获取相对路径的绝对路径 \tif tmpPath, err = filepath.Abs(relPath); err != nil { panic(err) } else { fmt.Println(\u0026#34;the abs path of rel path is:\u0026#34;, tmpPath) } // 获取绝对路径的相对路径 \tif tmpPath, err = filepath.Rel(\u0026#34;/etc/a\u0026#34;, \u0026#34;/etc/a.txt\u0026#34;); err != nil { panic(err) } else { fmt.Println(\u0026#34;the rel path of /etc/a.txt based on /etc/a is:\u0026#34;, tmpPath) } } 输出：\n╰─$ go run main.go absPath is asb path: true relPath is abs path: false the abs path of rel path is: /Users/wangtingkui/Projects/learnGo/filepath/a.txt the rel path of /etc/a.txt based on /etc/a is: ../a.txt 文件路径的拆分 对于一个确定是文件的路径，我们可以使用Split将他拆分为目录路径和文件名，这个函数拆分之后一定会保证 path = dir + file\n代码：\nfunc main() { var ( filePaths = []string{ \u0026#34;/etc/a.txt\u0026#34;, \u0026#34;/etc/\u0026#34;, \u0026#34;/etc\u0026#34;, \u0026#34;etc/\u0026#34;, \u0026#34;etc\u0026#34;, \u0026#34;\u0026#34;, } ) for _, filePath := range filePaths { dir, file := filepath.Split(filePath) fmt.Printf(\u0026#34;dir is :%s , file is :%s\\n\u0026#34;, dir, file) } } 输出：\ndir is :/etc/ , file is :a.txt dir is :/etc/ , file is : dir is :/ , file is :etc dir is :etc/ , file is : dir is : , file is :etc dir is : , file is : 规范化路径 有的路径虽然可以使用，但是看起来非常的绕，不易阅读和维护，比如ls /../etc/../etc/ 其实就是ls /etc，Clean就是用来清理这样的路径的\n代码：\nfunc main() { var ( filePaths = []string{ \u0026#34;/../etc/../etc/\u0026#34;, \u0026#34;../a/./../a\u0026#34;, } ) for _, filePath := range filePaths { fmt.Println(filepath.Clean(filePath)) } } 输出：\n╰─$ go run main.go /etc ../a 路径的拼接 可以使用Join来拼任意多段路径，这个函数会根据情况添加合适的路径分隔符，也会保证返回的结果是Clean过的\n代码：\nfunc main() { fmt.Println(filepath.Join(\u0026#34;/etc/\u0026#34;, \u0026#34;/a.txt\u0026#34;)) fmt.Println(filepath.Join(\u0026#34;/etc\u0026#34;, \u0026#34;a.txt\u0026#34;)) } 输出：\n╰─$ go run main.go /etc/a.txt /etc/a.txt 返回符合指定模式的文件列表 代码：\nfunc main() { if paths, err := filepath.Glob(\u0026#34;./*.go\u0026#34;); err != nil { panic(err) } else { for _, path := range paths { fmt.Println(path) } } } 输出：\n╰─$ go run main.go main.go 遍历目录树 filepath这个包给我们提供了一个方便的方法Walk来遍历我们的目录树\n代码：\nfunc main() { filepath.Walk(\u0026#34;.\u0026#34;, func(path string, info os.FileInfo, err error) error { if info.IsDir() { return nil } fmt.Println(\u0026#34;file:\u0026#34;, info.Name(), \u0026#34;in directory:\u0026#34;, path) return nil }) } 输出：\n╰─$ go run main.go file: main.go in directory: main.go ","id":23,"section":"posts","summary":"简介 这个库主要是对文件路径的操作，是比较常用的一个库，由于这个库比较简单，没有什么需要过多的说明，大部分的方法会以实例的形式来展示 而且要注意","tags":["go"],"title":"Go标准库（path/filepath）- 使用","uri":"https://wangtingkui.github.io/2019/12/path-filepath/","year":"2019"},{"content":"之前写php，使用phpbrew来进行php的版本管理，非常方便，同样的，go也有自己的多版本管理工具gvm，这篇文章就记录下如何在mac下使用gvm进行go的多版本管理\ngvm的信息可以参考：https://github.com/moovweb/gvm\n环境信息  macOS 10.15.2 brew 2.1.16  安装gvm bash \u0026lt; \u0026lt;(curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer) 下载好之后，需要修改下个人配置文件，使gvm相关命令生效，如果用的是bash，则修改~/.bashrc，如果习惯用zsh，那就修改~/.zshrc，以此类推\n[[ -s \u0026#34;$HOME/.gvm/scripts/gvm\u0026#34; ]] \u0026amp;\u0026amp; source \u0026#34;$HOME/.gvm/scripts/gvm\u0026#34; 修改之后，重开一会会话或者直接source ~/.zshrc（我用的是zsh）让刚才的修改生效。执行一下看下效果\n╰─$ gvm version Go Version Manager v1.0.22 installed at /Users/wangtingkui/.gvm 可以看到，我装的是 1.0.22 的版本\n常用命令 # 查看gvm版本 gvm version # 查看所有可以安装的版本 gvm listall # 查看本地已经安装的版本 gvm list # 安装指定版本 gvm install go1.13.5 # 删除指定版本 gvm uninstall go1.13.5 # 临时切换版本 gvm use go1.13.5 # 切换版本并指定为默认版本 gvm use go1.13.5 --default 使用 由于go是使用自举的方式来编译，也就是用go来编译go，所有我们使用gvm来初始安装一个版本的时候，首先需要保证在自己的环境中有go，我是直接使用brew安装的，大家也可以使用其他方式下载安装\n 下面是我的安装过程\n brew install go gvm listall # 看下有哪些版本 gvm install go1.13.6 # 选择一个版本安装 brew unlink go # 使用gvm安装完之后就可以不适用brew安装的go了，所以直接断开连接 gvm use go1.13.6 --default # 选择刚才安装的版本并且设置为默认版本 当我们使用gvm use \u0026lt;version\u0026gt;切换版本的时候，可以使用go env GOPATH看下，可以发现随着我们切换版本，GOPATH的路径也在变换，这样就不用害怕不同版本GOPATH下的内容冲突了\n","id":24,"section":"posts","summary":"之前写php，使用phpbrew来进行php的版本管理，非常方便，同样的，go也有自己的多版本管理工具gvm，这篇文章就记录下如何在mac下","tags":["go"],"title":"go多版本管理","uri":"https://wangtingkui.github.io/2019/12/go-multi-version-manage/","year":"2019"},{"content":"上一篇文章中简单介绍了如何使用cobra框架，这篇文章让我们来看下cobra的源码，本文基于的cobra版本是v0.0.5\n首先需要了解的是，在cobra中，所有的命令会组成一个树的结构，必然有一个根命令，我们应用的每次执行，都是从这个根命令开始的，官方文档也说过，基于cobra的应用的main包中的代码是很简单的，几乎没有额外的操作，仅有的操作其实就是执行我们的根命令。所以自然而然的，我们的代码分析之旅也是从根命令的执行开始的。\n为了有个直观的感受，我简单生成了一个基于cobra的应用。这个应用有一个根命令和一个test1的子命令，项目结构如下：\n╰─$ tree . . ├── LICENSE ├── cmd │ ├── root.go │ └── test1.go ├── go.mod ├── go.sum └── main.go 1 directory, 6 files 主线执行分析 所有的项目不可能都是简单的一条线到底，代码总会有很多分支，但我们阅读源码的时候精力和关注度总是有限的（不是有人说人在同一时间关注的点不能超过7个还是几个来着么），如果代码里面的每个分支都去看，每个函数的调用都进去瞅瞅，很快我们就会迷失在复杂的代码里面，忘了我们怎么看到的这行代码，所以本文去分析源码的时候，会优先挑一条主线，主要跟踪这条主线上的逻辑和调用，忽略其他支线。当然，也会有比较重要的其他支线，但是和当前的主线无关，会单开一个小节去阅读分析\ncobra主线自然是入口-找到目标命令-分析参数-执行这条路径啦~\n看下main.go文件中都有点啥\npackage main import \u0026#34;learnCobra/cmd\u0026#34; func main() { cmd.Execute() } 简洁的一比，直接进入cmd.Execute\nfunc Execute() { if err := rootCmd.Execute(); err != nil { fmt.Println(err) os.Exit(1) } } 可以看到，其实就是执行了根命令的Execute方法，这个方法才是我们的重头戏。当然，所谓的根命令只是从命令的组织形态上来说的，所有的命令都是cobra.Command的这个结构体，后面绝大多数的代码也都是对这个结构体的成员和方法的分析\nfunc (c *Command) Execute() error { _, err := c.ExecuteC() return err } 毫无波澜，直接进c.ExecuteC()，这里开始我会在源码里面写点注释了\nfunc (c *Command) ExecuteC() (cmd *Command, err error) { // Regardless of what command execute is called on, run on Root only \t// 前面说过，我们所有的命令构成了一棵树，每次执行都是从根命令开始执行的 \t// 如果我们手残在代码的某处直接执行了一个子命令，这个方法也会向上遍历到根，然后执行根命令的 \tif c.HasParent() { return c.Root().ExecuteC() } // windows hook \t// windows 系统的钩子，不用care \tif preExecHookFn != nil { preExecHookFn(c) } // initialize help as the last point possible to allow for user \t// overriding \t// 初始化默认的帮助命令，不是我们的主线，不care \tc.InitDefaultHelpCmd() args := c.args // Workaround FAIL with \u0026#34;go test -v\u0026#34; or \u0026#34;cobra.test -test.v\u0026#34;, see #155 \t// 如果没有设置过命令的调用参数，使用os.Args[1:]作为默认参数 \tif c.args == nil \u0026amp;\u0026amp; filepath.Base(os.Args[0]) != \u0026#34;cobra.test\u0026#34; { args = os.Args[1:] } // 找真正要执行的命令，并解析flag \t// cobra为我们提供了两种flag，一种叫 persistant flag， \t// 这种 flag 可以在子命令中也获取到 \t// 另外一种叫 local flag \t// 这种 flag 只会在指定命令中被解析 \t// 默认情况下，cobra 只会解析目标命令的 local flag，父命令中的local flag将会被忽略 \t// 可以将命令的 TraverseChildren 属性置为 true ，cobra 会在执行命令前解析所有命令 \t// 的 local flag \tvar flags []string if c.TraverseChildren { cmd, flags, err = c.Traverse(args) } else { // 我们当然是挑软柿子捏，当然挑这条简单的路走 \tcmd, flags, err = c.Find(args) } if err != nil { // If found parse to a subcommand and then failed, talk about the subcommand \tif cmd != nil { c = cmd } if !c.SilenceErrors { c.Println(\u0026#34;Error:\u0026#34;, err.Error()) c.Printf(\u0026#34;Run \u0026#39;%v --help\u0026#39; for usage.\\n\u0026#34;, c.CommandPath()) } return c, err } // 记录这个命令被调用过了，和被调用的名字 \tcmd.commandCalledAs.called = true if cmd.commandCalledAs.name == \u0026#34;\u0026#34; { cmd.commandCalledAs.name = cmd.Name() } // 执行找到的命令 \terr = cmd.execute(flags) if err != nil { // Always show help if requested, even if SilenceErrors is in \t// effect \tif err == flag.ErrHelp { cmd.HelpFunc()(cmd, args) return cmd, nil } // If root command has SilentErrors flagged, \t// all subcommands should respect it \tif !cmd.SilenceErrors \u0026amp;\u0026amp; !c.SilenceErrors { c.Println(\u0026#34;Error:\u0026#34;, err.Error()) } // If root command has SilentUsage flagged, \t// all subcommands should respect it \tif !cmd.SilenceUsage \u0026amp;\u0026amp; !c.SilenceUsage { c.Println(cmd.UsageString()) } } return cmd, err } 这里就有两个比较重要的方法了，c.Find和cmd.execute，我们先来看下怎么找到的目的命令\nfunc (c *Command) Find(args []string) (*Command, []string, error) { // 声明了一个函数类型的变量 \tvar innerfind func(*Command, []string) (*Command, []string) // 定义了这个函数 \tinnerfind = func(c *Command, innerArgs []string) (*Command, []string) { // 去掉 flag， 剩下的就是参数 \targsWOflags := stripFlags(innerArgs, c) if len(argsWOflags) == 0 { return c, innerArgs } // 参数的第一个就是要执行的命令 \tnextSubCmd := argsWOflags[0] // 在子命令中去找有没有匹配 nextSubCmd 的子命令 \tcmd := c.findNext(nextSubCmd) if cmd != nil { // 递归的判断有没有匹配的子命令了 \treturn innerfind(cmd, argsMinusFirstX(innerArgs, nextSubCmd)) } return c, innerArgs } // 调用了上面定义的那个函数，我擦，我也不知道作者为什么这样写 \t// 怕了怕了。。。先跳上去看逻辑吧 \tcommandFound, a := innerfind(c, args) if commandFound.Args == nil { return commandFound, a, legacyArgs(commandFound, stripFlags(a, commandFound)) } return commandFound, a, nil } 然后我们再来看看cmd.execute\nfunc (c *Command) execute(a []string) (err error) { // 如果命令是个nil，那还执行个蛋 \tif c == nil { return fmt.Errorf(\u0026#34;Called Execute() on a nil Command\u0026#34;) } // 通过 Deprecated 这个属性判断这个命令是否将要被废弃 \tif len(c.Deprecated) \u0026gt; 0 { c.Printf(\u0026#34;Command %q is deprecated, %s\\n\u0026#34;, c.Name(), c.Deprecated) } // initialize help and version flag at the last point possible to allow for user \t// overriding \t// 添加默认的帮助flag和版本flag \tc.InitDefaultHelpFlag() c.InitDefaultVersionFlag() // 解析flag \terr = c.ParseFlags(a) if err != nil { return c.FlagErrorFunc()(c, err) } // If help is called, regardless of other flags, return we want help. \t// Also say we need help if the command isn\u0026#39;t runnable. \t// 如果使用了帮助flag，忽略其他的flag \thelpVal, err := c.Flags().GetBool(\u0026#34;help\u0026#34;) if err != nil { // should be impossible to get here as we always declare a help \t// flag in InitDefaultHelpFlag() \tc.Println(\u0026#34;\\\u0026#34;help\\\u0026#34; flag declared as non-bool. Please correct your code\u0026#34;) return err } // 如果指定了帮助flag，返回一个帮助类型错误，上层会处理，调用命令的 HelpFunc \tif helpVal { return flag.ErrHelp } // for back-compat, only add version flag behavior if version is defined \t// 如果设置了Version属性，并且传递了 version flag，输出版本信息 \tif c.Version != \u0026#34;\u0026#34; { versionVal, err := c.Flags().GetBool(\u0026#34;version\u0026#34;) if err != nil { c.Println(\u0026#34;\\\u0026#34;version\\\u0026#34; flag declared as non-bool. Please correct your code\u0026#34;) return err } if versionVal { err := tmpl(c.OutOrStdout(), c.VersionTemplate(), c) if err != nil { c.Println(err) } return err } } // 判断是否可运行（也就是是否设置了命令的 Run 或者 RunE 属性） \tif !c.Runnable() { return flag.ErrHelp } // 执行准备，其实就是执行通过cobra.OnInitialize注册的初始化方法 \tc.preRun() // 获取所有flag之外的参数 \targWoFlags := c.Flags().Args() if c.DisableFlagParsing { // 如果设置了 DisableFlagParsing 为 false \t// 也就是不解析 flag，把所有的参数当做命令的参数 \targWoFlags = a } // 通过命令的 Args 属性设置的方法验证我们的参数 \tif err := c.ValidateArgs(argWoFlags); err != nil { return err } // PersistentPreRun 钩子函数 \tfor p := c; p != nil; p = p.Parent() { if p.PersistentPreRunE != nil { if err := p.PersistentPreRunE(c, argWoFlags); err != nil { return err } break } else if p.PersistentPreRun != nil { p.PersistentPreRun(c, argWoFlags) break } } // PreRun 钩子函数 \tif c.PreRunE != nil { if err := c.PreRunE(c, argWoFlags); err != nil { return err } } else if c.PreRun != nil { c.PreRun(c, argWoFlags) } // 验证所有必要的flag \tif err := c.validateRequiredFlags(); err != nil { return err } // 执行自定义逻辑函数 \tif c.RunE != nil { if err := c.RunE(c, argWoFlags); err != nil { return err } } else { c.Run(c, argWoFlags) } // PostRun 钩子 \tif c.PostRunE != nil { if err := c.PostRunE(c, argWoFlags); err != nil { return err } } else if c.PostRun != nil { c.PostRun(c, argWoFlags) } // PersistentPostRun 钩子 \tfor p := c; p != nil; p = p.Parent() { if p.PersistentPostRunE != nil { if err := p.PersistentPostRunE(c, argWoFlags); err != nil { return err } break } else if p.PersistentPostRun != nil { p.PersistentPostRun(c, argWoFlags) break } } return nil } 到此，大概的命令执行流程我们就分析完了。可以发现，这次的分析过程，我们并没有预先把cobra.Command结构里面的成员先看一遍，因为里面的成员实在是太太太多了，简单看一遍几乎是秒忘，所以对于这种成员非常多的结构体，建议直接跟流程，看到用什么成员，再去结构里看这个成员的说明。\n以上就是我们的整个分析过程了，如果有空，之后会补充一些重要的支线逻辑\n","id":25,"section":"posts","summary":"上一篇文章中简单介绍了如何使用cobra框架，这篇文章让我们来看下cobra的源码，本文基于的cobra版本是v0.0.5 首先需要了解的是，","tags":["go","cobra","源码分析"],"title":"go cli 应用框架cobra（二）- 源码分析","uri":"https://wangtingkui.github.io/2019/12/cobra/","year":"2019"},{"content":"hugo 是一个静态网页生成器，关于它的使用就不再多说，可以参考之前写过的使用hugo搭建个人站点系列文章。本系列主要是分析下 hugo 的源码，看下其他人是如何实现一个大型的 cli 应用\n第一篇文章从 hugo version 命令出发，简单了解下 hugo 应用的整体流程和代码结构，为后续比较复杂的命令分析做准备\n本系列文章都是基于 hugo 0.57.2 版本叙述的\n命令简介 version 命令的作用数输出当前 hugo 的版本，基本上所有的 cli 应用都会有这样的命令\n一个 hugo version 的输出：\n╰─$ hugo version Hugo Static Site Generator v0.57.2-A849CB2D darwin/amd64 BuildDate: 2019-08-17T17:53:28Z 源码分析 hugo是基于 cobra 这个命令行应用框架做的，如果能了解下cobra的基本使用会对我们的源码分析过程有比较大的帮助，关于 cobra，可以参考之前的两篇文章\n go cli 应用框架cobra（一）- 简介 go cli 应用框架cobra（二）- 源码分析  为了使我们的分析过程比较轻松，先来看下在 hugo version 这条主线中，会涉及到哪些比较主要的结构体\n baseCmd\n type baseCmd struct { cmd *cobra.Command } func (c *baseCmd) getCommand() *cobra.Command { return c.cmd } func (c *baseCmd) flagsToConfig(cfg config.Provider) { initializeFlags(c.cmd, cfg) } 前面我们也提到过，hugo 是基于 cobra 框架开发的，baseCmd 其实就是对 cobra 的 cobra.Command 的简单封装\n commandsBuilder\n type commandsBuilder struct { hugoBuilderCommon commands []cmder } 这是一个命令的构建器，是它将我们的version,new,config,check\u0026hellip; 等命令打包起来放在一个命令的子命令中，从而使我们方便的使用，其实就是用来生成我们的根命令\n hugoCmd\n type hugoCmd struct { *baseBuilderCmd // Need to get the sites once built. \tc *commandeer } 上面提到了 commandsBuilder 将命令打包，其实就是新建了一个 hugoCmd，将我们的子命令都放到这个命令下，可以认为 hugoCmd 就是我们的 hugo 这个根命令\n了解了上面几个基本的结构体，下面就让我们进入源码分析之旅吧，首先看下 main.go 入口文件：\nfunc main() { resp := commands.Execute(os.Args[1:]) if resp.Err != nil { if resp.IsUserError() { resp.Cmd.Println(\u0026#34;\u0026#34;) resp.Cmd.Println(resp.Cmd.UsageString()) } os.Exit(-1) } } commands.Execute\n// Execute adds all child commands to the root command HugoCmd and sets flags appropriately. // The args are usually filled with os.Args[1:]. func Execute(args []string) Response { // 通过commandsBuilder生成hugoCmd，这个比较简单，就不深入看了 \thugoCmd := newCommandsBuilder().addAll().build() // 获取原始的 cobra.Command \tcmd := hugoCmd.getCommand() // 将os.Args[1:] 设置为根命令的参数 \tcmd.SetArgs(args) // 执行命令，这里执行的cobra的源码，有兴趣的可以看一下，返回的是真正的哪个命令被执行以及一个error \tc, err := cmd.ExecuteC() var resp Response if c == cmd \u0026amp;\u0026amp; hugoCmd.c != nil { // Root command executed \tresp.Result = hugoCmd.c.hugo() } if err == nil { errCount := int(loggers.GlobalErrorCounter.Count()) if errCount \u0026gt; 0 { err = fmt.Errorf(\u0026#34;logged %d errors\u0026#34;, errCount) } else if resp.Result != nil { errCount = resp.Result.NumLogErrors() if errCount \u0026gt; 0 { err = fmt.Errorf(\u0026#34;logged %d errors\u0026#34;, errCount) } } } resp.Err = err resp.Cmd = c return resp } ","id":26,"section":"posts","summary":"hugo 是一个静态网页生成器，关于它的使用就不再多说，可以参考之前写过的使用hugo搭建个人站点系列文章。本系列主要是分析下 hugo 的源码，看下其他人是","tags":null,"title":"hugo源码分析（一）- version","uri":"https://wangtingkui.github.io/2019/12/version/","year":"2019"},{"content":"hugo 内置了强大且支持自定义的分类系统，比如标签、类别、系列等，可以通过配置开启这些分类系统\n在config.toml中配置：\n[taxonomies] tag = \u0026quot;tags\u0026quot; category = \u0026quot;categories\u0026quot; seris = \u0026quot;series\u0026quot; 开启之后，只需要在文章的Front Matter对应的属性中，添加想要划分到的分类即可\n--- title: \u0026quot;php入门\u0026quot; date: 2019-10-10 tags: [\u0026quot;php\u0026quot;] categories: [\u0026quot;php\u0026quot;] series: [\u0026quot;php入门系列\u0026quot;] ","id":27,"section":"posts","summary":"hugo 内置了强大且支持自定义的分类系统，比如标签、类别、系列等，可以通过配置开启这些分类系统 在config.toml中配置： [taxonomies] tag = \u0026quot;tags\u0026quot; category = \u0026quot;categories\u0026quot; seris = \u0026quot;series\u0026quot;","tags":["go"],"title":"使用hugo搭建个人网站（七）- 给你的文章分类","uri":"https://wangtingkui.github.io/2019/12/hugo-categorize-your-artical/","year":"2019"},{"content":"github pages 为我们提供的站点域名是 \u0026lt;username\u0026gt;.github.io，但是有好多同学其实购买了自己的域名，那能否将自己的域名绑定到 github pages 上呢，当然是可以的\ngithub pages 支持多种域名类型，不同的域名类型配置有细微的区别\n配置二级域名 二级域名就是类似baidu.com这种，.com是顶级域,baidu是二级域\n首先进入到 github 仓库的设置，找到 GitHub Pages 项下的 Custom domain 配置项 输入你的二级域名，点击保存，这个操作会自动在你的仓库代码的根目录下添加一个CNAME文件 最后还需要在你的dns服务提供商那里配置一下域名解析，对于二级域名来说，你可以配置ALIAS记录,ANAME记录或者是A记录\n如果配置的是ALIAS或者ANAME，需要把你二级域名指向默认的站点域名，也就是\u0026lt;username.github,io\u0026gt;\n如果配置的是A记录，把你的二级域名指向下面的ip，具体会不会变化可以参考官方文档\n185.199.108.153 185.199.109.153 185.199.110.153 185.199.111.153 配置子域名 可以参考官方文档\n参考  github pages 官方文档  ","id":28,"section":"posts","summary":"github pages 为我们提供的站点域名是 \u0026lt;username\u0026gt;.github.io，但是有好多同学其实购买了自己的域名，那能否将自己的域名绑定到","tags":["go","github pages"],"title":"使用hugo搭建个人网站（八）- 自定义你的站点域名","uri":"https://wangtingkui.github.io/2019/12/hugo-custom-your-domain/","year":"2019"},{"content":"默认情况下，站点文章的 url 和我们 content 目录下的文件结构是一一对应的，比如有 content/posts/test.md 这篇文章，当我们发布之后，在站点访问的 url 就是 \u0026lt;domian\u0026gt;/posts/test，如果我们不想要这种形式，可以通过配置来改变默认的行为\n在使用配置之前，先让我们了解下 hugo 生成的 url 规则\n知道了每个段的含义，我们就可以使用hugo提供给我们的配置项来进行url的自定义\n可以在config.toml文件中的[permalinks]配置指定url的格式，比如\n[permalinks] post = \u0026quot;/:year/:month/:title/\u0026quot; 所有可用的属性如下\n:month :monthname :day :weekday :weekdayname :yearday :section :title :slug :filename ","id":29,"section":"posts","summary":"默认情况下，站点文章的 url 和我们 content 目录下的文件结构是一一对应的，比如有 content/posts/test.md 这篇文章，当我们发布之后，在站点访问的 url 就是 \u0026lt;domian\u0026gt","tags":["go"],"title":"使用hugo搭建个人网站（六）- 定制你文章的url","uri":"https://wangtingkui.github.io/2019/12/hugo-custom-your-url/","year":"2019"},{"content":"加入我们要寻找content/posts下文章的模板\n当我们未在Front Matter中指定type和layout属性的时候，hugo默认的模板查找顺序是：\n\u0026lt;project_path\u0026gt;/layouts/UNSPECIFIED/UNSPECIFIED.html \u0026lt;project_path\u0026gt;/layouts/posts/UNSPECIFIED.html \u0026lt;project_path\u0026gt;/layouts/UNSPECIFIED/single.html \u0026lt;project_path\u0026gt;/layouts/posts/single.html \u0026lt;project_path\u0026gt;/layouts/_default/single.html \u0026lt;project_path\u0026gt;/themes/\u0026lt;THEME\u0026gt;/layouts/UNSPECIFIED/UNSPECIFIED.html \u0026lt;project_path\u0026gt;/themes/\u0026lt;THEME\u0026gt;/layouts/posts/UNSPECIFIED.html \u0026lt;project_path\u0026gt;/themes/\u0026lt;THEME\u0026gt;/layouts/UNSPECIFIED/single.html \u0026lt;project_path\u0026gt;/themes/\u0026lt;THEME\u0026gt;/layouts/posts/single.html \u0026lt;project_path\u0026gt;/themes/\u0026lt;THEME\u0026gt;/layouts/_default/single.html 当指定了type和layout属性的时候，查找顺序是：\n\u0026lt;project_path\u0026gt;/layouts/review/reviewarticle.html \u0026lt;project_path\u0026gt;/layouts/posts/reviewarticle.html \u0026lt;project_path\u0026gt;/layouts/review/single.html \u0026lt;project_path\u0026gt;/layouts/posts/single.html \u0026lt;project_path\u0026gt;/layouts/_default/single.html \u0026lt;project_path\u0026gt;/themes/\u0026lt;THEME\u0026gt;/layouts/review/reviewarticle.html \u0026lt;project_path\u0026gt;/themes/\u0026lt;THEME\u0026gt;/layouts/posts/reviewarticle.html \u0026lt;project_path\u0026gt;/themes/\u0026lt;THEME\u0026gt;/layouts/review/single.html \u0026lt;project_path\u0026gt;/themes/\u0026lt;THEME\u0026gt;/layouts/posts/single.html \u0026lt;project_path\u0026gt;/themes/\u0026lt;THEME\u0026gt;/layouts/_default/single.html ","id":30,"section":"posts","summary":"加入我们要寻找content/posts下文章的模板 当我们未在Front Matter中指定type和layout属性的时候，hugo默认的模","tags":["go"],"title":"使用hugo搭建个人网站（五）- 模板选择顺序","uri":"https://wangtingkui.github.io/2019/12/hugo-template-order/","year":"2019"},{"content":"Front Matter 是扉页，前页的意思，顾名思义，他出现在我们文章的最前面，用来设定一些文章的元信息，比如是否是草稿，写作时间，文章所属的标签等等。\nFront Matter 支持4种配置语言 YAML,JSON,TOML,ORG，可以通过Front Matter的前导符（包裹Front Matter的定界符）来告诉hugo我们使用的是什么配置语言，各种配置语言的前导符如下：\n   格式 定界符     toml 开始和结束行使用+++   yaml 开始和结束行使用---   json 使用一个json对象，对象后需要跟一个空白行   org a group of Org mode keywords in the format ‘#+KEY: VALUE’. Any line that does not start with #+ ends the front matter section. Keyword values can be either strings (#+KEY: VALUE) or a whitespace separated list of strings (#+KEY[]: VALUE_1 VALUE_2).    Front Matter支持的标准配置有很多，但是只有两个属性是必须的，那就是title和date，代表了文章的标题和写作时间\n下面是hugo默认支持的常用Front Matter属性：\ntitle: \u0026#34;文章标题\u0026#34; date: 2012-12-12 description: \u0026#34;文章描述信息\u0026#34; tags: [\u0026#34;标签1\u0026#34;, \u0026#34;标签2\u0026#34;] categories: [\u0026#34;分类1\u0026#34;, \u0026#34;分类2\u0026#34;] keywords: [\u0026#34;关键字1\u0026#34;, \u0026#34;关键字2\u0026#34;] lastmod: 2015-10-10 isCJKLanguage: true # 是否是CJK语言 draft: true # 是否是草稿 expiryDate: 2020-10-10 # 文章过期时间 publishDate: 2020-10-10 # 文章发布时间 weight: 40 # 文章排序权重，数值越小越在前 # 使用这两个参数会重置permalink，默认使用文件名 url: slug: # 文章地址的别名 aliases: - /posts/hxxxx - xxxx # type 和 layout 将会改变 hugo 寻找文章模板的顺序 type: review layout: reviewartical 参考  官方文档  ","id":31,"section":"posts","summary":"Front Matter 是扉页，前页的意思，顾名思义，他出现在我们文章的最前面，用来设定一些文章的元信息，比如是否是草稿，写作时间，文章所属的标签等等。 Front Matter 支持","tags":["go"],"title":"使用hugo搭建个人网站（四）- Front Matter 配置详解","uri":"https://wangtingkui.github.io/2019/12/front-matter/","year":"2019"},{"content":"我们可以在文章中引用自己的其他文章，hugo 帮我们实现了这种功能，只需要在文章中使用 {{\u0026lt; ref \u0026quot;posts/my_post.md\u0026quot; \u0026gt;}}或者{{\u0026lt; relref \u0026quot;posts/my_post.md\u0026quot; \u0026gt;}}即可，前者是相对链接，后者是绝对链接\n这个功能其实是 hugo 提供的 Shortcodes功能\n一些例子：\n{{\u0026lt; ref \u0026quot;blog/post.md\u0026quot; \u0026gt;}} =\u0026gt; https://example.com/blog/post/ {{\u0026lt; ref \u0026quot;post.md#tldr\u0026quot; \u0026gt;}} =\u0026gt; https://example.com/blog/post/#tldr:caffebad {{\u0026lt; relref \u0026quot;post.md\u0026quot; \u0026gt;}} =\u0026gt; /blog/post/ {{\u0026lt; relref \u0026quot;blog/post.md#tldr\u0026quot; \u0026gt;}} =\u0026gt; /blog/post/#tldr:caffebad {{\u0026lt; ref \u0026quot;#tldr\u0026quot; \u0026gt;}} =\u0026gt; #tldr:badcaffe {{\u0026lt; relref \u0026quot;#tldr\u0026quot; \u0026gt;}} =\u0026gt; #tldr:badcaffe 如果是不是需要引用，而仅仅是需要展示{{\u0026lt; ref \u0026quot;blog/post.md\u0026quot; \u0026gt;}}这样的文本，需要在标签内加上/* */这样的注释，比如{{\u0026lt;/* ref \u0026quot;blog/post.md\u0026quot; */\u0026gt;}}\n","id":32,"section":"posts","summary":"我们可以在文章中引用自己的其他文章，hugo 帮我们实现了这种功能，只需要在文章中使用 {{\u0026lt; ref \u0026quot;posts/my_post.md\u0026quot; \u0026gt;}}或者{{\u0026lt; relref \u0026quot;posts/my_post.md\u0026quot; \u0026gt;}}即可，","tags":["hugo"],"title":"使用hugo搭建个人网站（三）- 引用其他文章","uri":"https://wangtingkui.github.io/2019/12/ref-other-article/","year":"2019"},{"content":"flag 包是官方给我们提供的解析命令行选项的标准包，本文主要对其进行源码分析，如果仅仅只是需要学会简单的使用，可以参考Go标准库（flag）- 使用核心数据类型 首先还是来看下flag包中有哪些核心的类型，主要有两个接口和两个结构体\ninterface:\n// 抽象类型， 我们后续也是通过这个接口来扩展我们flag包支持的数据类型的 type Value interface { String() string Set(string) error } type Getter interface { Value Get() interface{} } struct:\n// 代表一个命令行选项 type Flag struct { Name string // name as it appears on command line // 标签在命令行显示的名字  Usage string // help message // 帮助信息  Value Value // value as set // 标签的值  DefValue string // default value (as text); for usage message // 默认值（文本格式）；这也是一个用法的信息说明 } // 代表一个选项集合，其实可以认为就是在shell中敲入的命令被拆分解析之后就是FlagSet type FlagSet struct { // 当解析标签出现错误的时候，Usage就会被调用。这个字段是一个函数（不是一个方法），它可以指向  // 用户自己定义的错误处理函数。 \tUsage func() name string // 名字，一般默认是os.Args[0] \tparsed bool\t// 是否已经解析过了（是否调用过flag.Parse()） \tactual map[string]*Flag // 解析过得flag数组 \tformal map[string]*Flag // 注册的flag数组 \targs []string // 解析过后，剩余的non-flag参数 \terrorHandling ErrorHandling // 解析失败后的处理方式 \toutput io.Writer // nil means stderr; use out() accessor } 源码分析 很多包在提供了底层类型的同时，为了方便我们使用，经常会在包内初始化一个默认对象，然后在开放一些导出函数供我们使用，flag 包也是这样的，标准库的实现者在包内初始化了一个名为CommandLine的FlagSet类型对象，我们经常使用的flag.String(),flag.BoolVal()等方法其实就是对这个对象的操作\n接下来就让我们追踪下最常用的flag.String的调用，看下flag包的内部实现逻辑吧\n注册 flag.String\n// 可以看到，flag.String 其实是对 CommandLine 对象 String 方法的包装，和我们刚才提到的是吻合的 func String(name string, value string, usage string) *string { return CommandLine.String(name, value, usage) } CommandLine.String\n// 帮我们创建了一个string类型的指针，返回给后续使用， // 这里也可以看到，Xxx()这种方法比XxxVar()的方法只是多了一步帮我们创建变量的过程，其实更底层是一样的 func (f *FlagSet) String(name string, value string, usage string) *string { p := new(string) f.StringVar(p, name, value, usage) return p } f.StringVar\n// FlagSet.StringVar 将我们的string类型的指针包装成了 stringValue 这个实现了 Value 接口的类型 func (f *FlagSet) StringVar(p *string, name string, value string, usage string) { f.Var(newStringValue(value, p), name, usage) } f.Var\nfunc (f *FlagSet) Var(value Value, name string, usage string) { // 创建一个Flag对象 \tflag := \u0026amp;Flag{name, usage, value, value.String()} // 检测是否已经注册过同名的flag \t_, alreadythere := f.formal[name] if alreadythere { var msg string if f.name == \u0026#34;\u0026#34; { msg = fmt.Sprintf(\u0026#34;flag redefined: %s\u0026#34;, name) } else { msg = fmt.Sprintf(\u0026#34;%s flag redefined: %s\u0026#34;, f.name, name) } fmt.Fprintln(f.Output(), msg) panic(msg) // Happens only if flags are declared with identical names \t} // 初始化formal \tif f.formal == nil { f.formal = make(map[string]*Flag) } // 放到注册的标记集合中 \tf.formal[name] = flag } 解析 执行到这里，我们的选项注册工作已经完成了，下一步就是命令行参数的解析，从而把用户真正的输入拿到，执行解析，我们调用的方法是flag.Parse\nflag.Parse\n// 其实是对FlagSet.Parse的封装 // 同时也看到，flag包对参数的解析默认是从命令行输入的第二个字符串开始的 func Parse() { // Ignore errors; CommandLine is set for ExitOnError. \tCommandLine.Parse(os.Args[1:]) } CommandLine.Parse\nfunc (f *FlagSet) Parse(arguments []string) error { // 将解析标记置为true，标记这个FlagSet已经被解析过了 \tf.parsed = true // 将所有参数放到盛放non-flag参数的容器中 \t// 后续解析过程会一个一个参数从这个容器中往外拿，直到解析结束 \tf.args = arguments for { // 逐个解析参数 \tseen, err := f.parseOne() if seen { continue } // 解析完成，退出循环，f.parseOne 返回 false,nil 的时候 \tif err == nil { break } // 如果有error发生，根据设置定的error处理方式处理error \tswitch f.errorHandling { case ContinueOnError: return err case ExitOnError: os.Exit(2) case PanicOnError: panic(err) } } return nil } f.parseOne\n// 这个方法是最主要的一个方法，他解析我们的参数 // 这个方法是被循环调用的，决定解析是否终止的条件也在这个方法中，在源码中我会标记出来 func (f *FlagSet) parseOne() (bool, error) { // 没有参数，不需要解析 \tif len(f.args) == 0 { return false, nil } s := f.args[0] // 结束条件1：字符串长度小于零或者不是以 - 字符开头的 \tif len(s) \u0026lt; 2 || s[0] != \u0026#39;-\u0026#39; { return false, nil } numMinuses := 1 if s[1] == \u0026#39;-\u0026#39; { numMinuses++ // 结束条件2：字符串是以 -- 开头的 \tif len(s) == 2 { // \u0026#34;--\u0026#34; terminates the flags \tf.args = f.args[1:] return false, nil } } // 取出真正的字符值（去掉前缀 - 或者 -- ） \tname := s[numMinuses:] // 字符串合法检测 \tif len(name) == 0 || name[0] == \u0026#39;-\u0026#39; || name[0] == \u0026#39;=\u0026#39; { return false, f.failf(\u0026#34;bad flag syntax: %s\u0026#34;, s) } // it\u0026#39;s a flag. does it have an argument? \tf.args = f.args[1:] hasValue := false value := \u0026#34;\u0026#34; // 通过等号判断是不是 \u0026#34;name=value\u0026#34; 这种格式类型的flag \tfor i := 1; i \u0026lt; len(name); i++ { // equals cannot be first \tif name[i] == \u0026#39;=\u0026#39; { value = name[i+1:] hasValue = true name = name[0:i] break } } m := f.formal // 判断是否注册过指定名称的flag \tflag, alreadythere := m[name] // BUG \tif !alreadythere { // 默认支持解析 help 和 h 选项 \tif name == \u0026#34;help\u0026#34; || name == \u0026#34;h\u0026#34; { // special case for nice help message. \tf.usage() return false, ErrHelp } return false, f.failf(\u0026#34;flag provided but not defined: -%s\u0026#34;, name) } // bool类型的flag支持 -flag 形式的写法，传了标记就是true，不传就依赖默认值 \tif fv, ok := flag.Value.(boolFlag); ok \u0026amp;\u0026amp; fv.IsBoolFlag() { // special case: doesn\u0026#39;t need an arg \tif hasValue { if err := fv.Set(value); err != nil { return false, f.failf(\u0026#34;invalid boolean value %q for -%s: %v\u0026#34;, value, name, err) } } else { if err := fv.Set(\u0026#34;true\u0026#34;); err != nil { return false, f.failf(\u0026#34;invalid boolean flag %s: %v\u0026#34;, name, err) } } } else { // It must have a value, which might be the next argument. \tif !hasValue \u0026amp;\u0026amp; len(f.args) \u0026gt; 0 { // value is the next arg \thasValue = true value, f.args = f.args[0], f.args[1:] } if !hasValue { return false, f.failf(\u0026#34;flag needs an argument: -%s\u0026#34;, name) } if err := flag.Value.Set(value); err != nil { return false, f.failf(\u0026#34;invalid value %q for flag -%s: %v\u0026#34;, value, name, err) } } // 初始化f.actual \tif f.actual == nil { f.actual = make(map[string]*Flag) } // 放在解析后的容器里面 \tf.actual[name] = flag return true, nil } ","id":33,"section":"posts","summary":"flag 包是官方给我们提供的解析命令行选项的标准包，本文主要对其进行源码分析，如果仅仅只是需要学会简单的使用，可以参考Go标准库（flag）- 使用","tags":null,"title":"Go标准库（flag）- 源码分析","uri":"https://wangtingkui.github.io/2019/12/flag/","year":"2019"},{"content":"本文所讨论内容基于的go版本：go1.13\n在我们编写命令行程序的时候，解析命令行的参数是非常常见的一种需求，Go标准库中的flag包为我们提供了解析命令行参数的功能\n要使用flag包，主要有3个步骤：定义flag、解析flag、使用flag\n定义flag flag包为我们提供了两种定义flag的方式，flag.Xxx()方式和flag.XxxVar()方式,其中Xxx可以是Int,String等类型，其中第一种会返回对应类型的指针，第二种则是将flag绑定到一个变量上\n// 方式1 var config *string = flag.String(\u0026#34;config\u0026#34;. \u0026#34;path/to/config\u0026#34;, \u0026#34;配置文件路径\u0026#34;) // 方式2 var intval int flag.IntVal(\u0026amp;intval, \u0026#34;intval\u0026#34;, 1, \u0026#34;a intger value\u0026#34;) 除了标准库中提供的基础数据类型的解析，如果我们需要解析自定义的类型，可以使用flag.Val()方法，只要绑定的类型实现了flag.Value接口即可\n解析flag 当定义完了所有的flag之后，我们可以调用flag.Parse()方法解析命令行参数\n使用flag 当使用命令行传递flag的时候，有以下三种语法格式（虽说官方只写了一个-，但其实当flag是bool类型的时候--也是支持的，但最好还是按照官方的来）\n-flag // 只支持 bool 类型 -flag value // 只支持非 bool 类型，因为比如有`cmd -x false`这种格式，不能确定false到底是flag的值还是一个参数 -flag=value 在命令行传递参数时，如果是int类型，可以传递十进制、十六进制、八进制或者是负数；如果是bool类型，可以使用1,0,t,g,true,false,TRUE,FALSE,True,Flase；如果是duration，可以接受任何time.ParseDuration可以解析的类型\nnon-flag 参数 在上面的说明中我们知道，传递参数的时候有固定格式，那不符合这些格式的参数就是non-flag参数\n在代码中，我们可以通过下面的这些方法来获取和使用non-flag参数\nflag.Arg(i int) // 获取第i个non-flag参数 flag.Args() // 获取所有的non-flag参数 flag.NArg() // 获取non-flag参数的个数 一个例子 package main import ( \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { var ( s = flag.String(\u0026#34;s\u0026#34;, \u0026#34;defaut string value\u0026#34;, \u0026#34;flag of type string\u0026#34;) i = flag.Int(\u0026#34;i\u0026#34;, 0, \u0026#34;flag of type int\u0026#34;) ) flag.Parse() output := fmt.Sprintf(`value of s flag:%s value of i flag:%d count of non-flag:%d item of non-flag:%v`, *s, *i, flag.NArg(), flag.Args()) fmt.Println(output) } 查看下输出：\n╰─$ ./flag -i 10 -s abc haha hehe value of s flag:abc value of i flag:10 count of non-flag:2 item of non-flag:[haha hehe] ","id":34,"section":"posts","summary":"本文所讨论内容基于的go版本：go1.13 在我们编写命令行程序的时候，解析命令行的参数是非常常见的一种需求，Go标准库中的flag包为我们提","tags":["go"],"title":"Go标准库（flag）- 使用","uri":"https://wangtingkui.github.io/2019/12/flag/","year":"2019"},{"content":"上一篇文章已经让我们简单了解了如何使用hugo，但是我们使用hugo的最终目的还是依靠它去搭建一个我们的个人站点，hugo能解决的是静态站点的生成，那么剩下的一个问题就是如何部署我们生成的站点，供其他人访问\n这篇文章帮助我们了解如何使用github pages的功能来部署我们的个人站点\n使用 github pages 的好处  完全免费 不需要自己购买服务器 不需要自己运行维护 可以方便的使用https  github pages 的限制 当然github pages本身还是有一些限制的\n 网站大小不能超过1GB 网站不能发布的过于频繁（每小时不超过10个版本） 每个月流量上限为1000GB  但是作为个人博客来说，这些限制几乎对我们没什么影响\n如何使用 github pages github pages 官方文档\n 申请一个github账号，每个github账号可以有一个个人站点和多个项目站点（这个以后有机会在单独写文章说一下） 创建一个\u0026lt;username\u0026gt;.github.io的仓库 当我们执行hugo命令去生成我们的静态站点的文件时，默认会放在当前目录的public目录（当然你也可以通过配置hugo从而指定目录），所以我们直接把创建好的仓库拉取到项目下的public目录即可git clone git@github.com:wangtingkui/wangtingkui.github.io.git ./public 指定hugo命令生成站点文件 进入public文件夹，将生成的文件提交到git，然后推送到远端即可  cd public git add . git commit -m \u0026#34;提交信息\u0026#34; git push -u origin master 推送之后，访问\u0026lt;username\u0026gt;.github.io你就会惊奇的发现你的个人站点已经可以访问了，如果访问的时候没有效果，也不要着急，那是github还在处理中，去休息一下，过段时间在访问就会生效啦~\n","id":35,"section":"posts","summary":"上一篇文章已经让我们简单了解了如何使用hugo，但是我们使用hugo的最终目的还是依靠它去搭建一个我们的个人站点，hugo能解决的是静态站点","tags":["go"],"title":"使用hugo搭建个人网站（二）- 使用 github pages 部署 hugo 生成的静态站点","uri":"https://wangtingkui.github.io/2019/12/deploy-on-github-pages/","year":"2019"},{"content":"简介 cobra是一个go语言的命令行应用框架，他也是一个用来快速生成命令行应用的脚手架\n一些基础概念 cobra推崇的是The best applications will read like sentences when used. Users will know how to use the application because they will natively understand how to use it.也就是我们的应用应该做到自解释，让使用者可以很容易的上手，使用的时候就像是说话一样的简单和自然\n一个遵循这个理念的命令行应用模式是 APPNAME VERB NOUN -ADJECTIVE 或者换种表达方式 APPNAME COMMADN ARG --FLAG\n APPNAME是我们应用的名称 COMMAND是我们要执行的动作，一般是个动词 ARG是我们动作作用的对象，一般是个名词 --FLAG是用来调整我们动作的行为，一般是个形容词  一个例子：git clone URL --bare\n项目结构 我们可以按照自己的喜好去组织我们的项目代码，但是一般情况下，基于cobra的项目会有以下的项目结构\n╰─$ tree . ├── LICENSE ├── cmd │ └── root.go └── main.go 1 directory, 3 files 快速上手构建项目 上面也提到了，cobra 不仅仅是一个命令行框架，它也能辅助我们快速生成我们的项目文件，接下来就让我们使用 cobra 提供的脚手架帮助我们生成基于 cobra 框架的命令行应用（如果还没有安装cobra脚手架，可以进入github.com/spf13/cobra/cobra然后go install一下）\n# 创建项目 cobra init --pkg-name github.com/wangtingkui/testCobra ./testCobra # 创建完成之后，就可以看到我们上面那个默认的目录结构了 # 给我们的应用添加命令 cobra add serve # 添加 serve 命令 cobra add config # 添加 config 命令 cobra add create -p 'configCmd' # 给 config 命令添加 create 子命令，`-p`指定这个命令的父命令，这个没有什么逻辑校验，就是在新命令的文件中init方法里面添加`configCmd.AddCommand(createCmd)`这行代码而已 创建完成之后，再来看下最终生成的目录结构\n╰─$ tree . ├── LICENSE ├── cmd │ ├── config.go │ ├── create.go │ ├── root.go │ └── serve.go └── main.go 1 directory, 6 files 测试下我们的项目\n主应用\n╰─$ ./testCobra A longer description that spans multiple lines and likely contains examples and usage of using your application. For example: Cobra is a CLI library for Go that empowers applications. This application is a tool to generate the needed files to quickly create a Cobra application. Usage: testCobra [command] Available Commands: config A brief description of your command help Help about any command serve A brief description of your command Flags: --config string config file (default is $HOME/.testCobra.yaml) -h, --help help for testCobra -t, --toggle Help message for toggle Use \u0026quot;testCobra [command] --help\u0026quot; for more information about a command. serve 命令\n╰─$ ./testCobra serve serve called ","id":36,"section":"posts","summary":"简介 cobra是一个go语言的命令行应用框架，他也是一个用来快速生成命令行应用的脚手架 一些基础概念 cobra推崇的是The best applications will read like sentences when used. Users","tags":null,"title":"go cli 应用框架cobra（一）- 简介","uri":"https://wangtingkui.github.io/2019/12/cobra/","year":"2019"},{"content":"作为一名coder，日常的开发工作中不可避免的会接触一些字符编码相关的东西，之前只是模模糊糊的了解一点，没有明确的，系统性的认知。一个最典型的例子就是当我们的代码遇到了乱码，这时候其他人总会告诉我们要使用utf-8编码就可以解决问题，但这背后蕴含的原理，却一直没有探索过，所以就查了一些资料，将查到的资料提炼汇总，有了这篇文章\n字符编码的发展历程 我们知道，所有的数据在计算机中都是用二进制串来表示的，那么人类世界的语言符号，想要在计算机中表示，就必须有对应的转换规则，这就是字符编码\nASCII 时期 上世纪60年代，美国制定了一套字符编码，它使用一个字节来对英语字符和二进制串进行映射，这就是ASCII码。\nASCII一共规定了128个字符，其中包含32个控制字符，由于ASCII只有128个字符，所以只占用了一个字节的7位，所以规定最前面的1位统一为0\n传统字符编码时期 由于不是所有国家的语言体系都是英文，比如中国使用的汉字，字符数量就远远超过了一个字符所能容纳的极限，所有随着计算机的普及，各个国家都提出了自己的字符编码方案，基本的策略就是使用更多的字节空间，兼容ASCII，然后用剩下的空间来编码其他的字符。比如中国的GB2312、BIG5等，但是这就导致了一个问题，各个国家都只是兼容了ASCII，然后编码了本国语言，对其他语言是不支持的，所以导致当时的计算机只能处理双语言环境，不支持多语言环境。\n假如遇到要在一个文本中同时出现中文、英文、阿拉伯文的时候，就无法进行编码处理了。\nunicode 时期 为了解决传统编码方式带来的问题，unicode出现了，下面就让我们详细看下unicode是如何解决上面的这些问题的\n现代编码模型 在探讨unicode是个什么东西之前，我们先来了解一下现代编码模型，因为要完美解决上面提到的编码问题，以及保证这套字符编码的可扩展性（因为到现在为止，还不断有更多的字符在加入到我们的语言体系之中），已经不能只是用简单规定几个字节，然后将字符和编码一一对应来处理了。\n现代编码模型将字符编码从底向上分为了几个层次：\n 抽象字符表（Abstract Character Repertoire）   就是这个编码系统所包含的所有抽象字符的集合，比如ASCII编码里面就有128个抽象字符。抽象字符表可以是封闭的，比如ASCII，不允许添加新的字符，也可以是开放的，比如unicode，可以添加新的字符进去。要注意的是，抽象字符表是一个集合，集合有一个最大的特点就是无序的。\n  编码字符集（Coded Character Set）   抽象字符表是抽象字符的集合，集合是无序的。无序的抽象字符表其实没什么卵用，因为我们只能判断一个字符在不在这个抽象字符表中，却无法方便的引用这个字符。为了更好的描述和操作字符，我们为抽象字符表中的每个抽象字符关联一个数字编号，这个数字编号叫做Code Point（译为码位），编码字符集就是为所有的字符都分配了码位的字符集。\n  码位一般是非负整数，习惯上使用十六进制表示。码位的分配也不一定是连续的。\n  最常见的编码字符集就是UCS（Universal Character Set），这也是unicode标准下使用的编码字符集\n   - [0x0000,0xD7FF] 和 [0xE000,0x10FFFF] 这两个区间称为unicode标量值(unicode scala value) - [0xD800,0xDBFF] 称为 Hign-surrogate - [0xDC00,0xDFFF] 称为 Low-surrogate   字符编码表（Character Encoding Form）   当我们有了编码字符集之后，是不是所有的问题已经解决了呢，当然不是，上面提到过，字符集可以是开放的，所以理论上UCS需要的码位是无限的，但是就算是计算机中uint32，也只有4个字节，最多只能表示4294967295个码位，这样矛盾就出现了。解决这个矛盾的方案，就是字符编码表\n  字符编码表是一个将Unicode标量值(Unicode scalar value)一一映射为码元序列(Code Unit Sequences)的映射。 之所以必须是一一映射，那是因为我们不光要编码，也要解码。 在Unicode中，指定了三种标准的字符编码表，UTF-8,UTF-16,UTF-32。分别将Unicode标量值映射为比特数为8、16、32的码元的序列。 即，UTF-8的码元为uint8, UTF-16的码元为uint16, UTF-32的码元为uint32。 当然也有一些非标准的CEF，如UCS-2,UCS-4，在此不多介绍。\n  码元 Code unit: The minimal bit combination that can represent a unit of encoded text for processing or interchange. 码元是能用于处理或交换编码文本的最小比特组合。通常计算机处理字符的码元为一字节，即8bit。同时因为计算机中char其实是一种整形，而整形的计算往往以计算机的字长作为一个基础单元，通常来讲，也就是4字节。Unicode定义了三种不同的CEF，分别采用了1字节，2字节，4字节的码元，正好对应了计算机中最常见的三种整形长度。\n  如何将一个无限大的整数，一一映射为指定字宽的码元序列。 这个问题可以通过变长编码来解决。 无论是UTF-8还是UTF-16，本质思想都是通过预留标记位来指示码元序列的长度。从而实现变长编码的。\n  字符编码方案（Character Encoding Schema）   简单说，字符编码方案CES等于字符编码表CEF加上字节序列化的方案。\n  通过CEF，我们已经可以将字符转为码元(Code Unit)。无论是哪种UTF-X的码元，都可以找到计算机中与之对应的整形存放。那么现在我们能说存储处理交换字符这个问题解决了吗？ 还不行。 因为从码元落实到底层的存储，还有一些问题需要解决。 假设一个字符按照UTF16拆成了A，B两个码元，那实际存储的时候究竟应该把A放在前面呢还是B放在前面呢？而另一个程序又如何知道当前这份文件是按照什么样的端序存储码元的呢？ 无论是大端法与小端法的选择，还是用于决定编码字节序的标记，都是CES需要操心的方案。\n  所以Unicode实际上定义了7种字符编码方案CES\n   - UTF-8 - UTF-16LE - UTF-16BE - UTF-16 - UTF-32LE - UTF-32BE - UTF-32   UTF-8因为已经采用字节作为码元了，所以实际上是不存在字节序的问题。其他两种CES嘛，都有一个大端版本一个小端版本，还有一个随机应变大小端带BOM的版本\n  当然，这里也出现一个问题，UTF-X可以同时指代字符编码表CEF或者字符编码方案CES。UTF-8问题还好，因为UTF-8的字节序列化方案太朴素了，以至于CES和CEF都没什么区别。但其他两种：UTF-16,UTF-32，就比较棘手了。当我们说UTF-16时，既可以指代UTF-16字符编码表，又可以指代UTF-16字符编码方案。所以当有人说“这个字符串是UTF-16编码的”时，鬼知道他到底说的到底是一个（UTF-16 encoding form的）码元序列还是(UTF-16 encoding schema 的)带BOM序列化好的一串字节流\n  传输编码语法（Transfer Encoding Syntax）   通过CES，我们已经可以将一个字符表示为一个字节序列。 但是有时候，字节序列表示还不够。比如在HTTP协议中，在URL里，一些字符是不允许出现的。这时候就需要再次对字节流进行编码。\n  著名的Base64编码，就是把字节流映射成了一个由64个安全字符组成字符集所表示的字符流。从而使字节流能够安全地在Web中传输。\n 参考文章  http://vonng.com/blog/character-set/  ","id":37,"section":"posts","summary":"作为一名coder，日常的开发工作中不可避免的会接触一些字符编码相关的东西，之前只是模模糊糊的了解一点，没有明确的，系统性的认知。一个最典型","tags":["字符编码","unicode","utf-8"],"title":"详解字符编码","uri":"https://wangtingkui.github.io/2019/09/unicode/","year":"2019"},{"content":"以blog为例，看看hugo是如何使用的\n创建一个网站项目 hugo new site blog， 执行这个命令后，会在当前目录下创建一个blog目录 ，这个目录就是我们的项目目录\n简单了解下目录的结构\n. ├── archetypes # 存储 .md 的模板文件 │ └── default.md ├── config.toml # 配置文件 ├── content # 存储网站所有的内容 ├── data # 存储数据文件供模板调用 ├── layouts # 存储 .html 模板 ├── static # 存储图片、css、js等静态文件，该目录下的文件会直接拷贝到 /public └── themes # 存储主题 6 directories, 2 files 快速体验 让我们快速体验下hugo的威力\nhugo创建出来的项目默认不带有任何主题，我们直接从github上随便搞一个，放到之前提到的themes文件夹下\ngit clone https://github.com/budparr/gohugo-theme-ananke.git ./themes/ananke\n然后在配置文件中配置应用这个主题\necho 'theme = \u0026quot;ananke\u0026quot;' \u0026gt;\u0026gt; config.toml\n接下来该正常的用markdown写作我们的文章了，使用如下命令新建一个文章\nhugo new post/my-first-post.md\n可以看到在content文件夹下多出了一个post文件夹，里面有一个my-fisrt-post.md的markdown文件，我们看下创建出来的这个文件里面的内容都有什么\n content/post/my-first-post.md 文件内容\n --- title: \u0026#34;My First Post\u0026#34; date: 2019-09-22T14:53:48+08:00 draft: true --- 这些默认生成的内容其实就是文章的一些元信息，比如文章的标题，创建的时间等等，里面的具体属性我们稍后再细讲。那这些内容是根据什么生成的呢，还记得我们上面给出的目录结构么，archetypes目录用来存放 md 文件的模板，让我们进去瞅瞅里面有啥，vim archetypes/default.md\n archetypes/default.md 文件内容\n --- title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; date: {{ .Date }} draft: true --- 看起来是不是和我们刚才生成的文件结构超像，其实那个文件就是依据这个模板来的\n我们来改动下刚才生成的文件，编辑一些自定义的内容\n content/post/my-first-post.md 文件内容\n --- title: \u0026#34;My First Post\u0026#34; date: 2019-09-22T14:53:48+08:00 draft: true --- ### 这是我的第一篇文章  内容就是用来测试的啦~ 最重要的一步来了，生成我们的站点，hugo内置了一个server，方便我们在书写文章的过程中快速的预览到站点效果，只需要执行下面的命令即可\nhugo server -D\n其中-D选项是告诉hugo把草稿状态的文章也渲染出来，执行完之后，hugo就提示我们已经可以从http://localhost:1313去访问我们的站点了，赶紧去看一下，是不是很吊呢\n","id":38,"section":"posts","summary":"以blog为例，看看hugo是如何使用的 创建一个网站项目 hugo new site blog， 执行这个命令后，会在当前目录下创建一个blog目录 ，这个目录就是我们","tags":["go"],"title":"使用hugo搭建个人网站（一）- hugo使用入门","uri":"https://wangtingkui.github.io/2019/09/introduction/","year":"2019"}],"tags":[{"title":"alfred","uri":"https://wangtingkui.github.io/tags/alfred/"},{"title":"atom","uri":"https://wangtingkui.github.io/tags/atom/"},{"title":"cobra","uri":"https://wangtingkui.github.io/tags/cobra/"},{"title":"github pages","uri":"https://wangtingkui.github.io/tags/github-pages/"},{"title":"go","uri":"https://wangtingkui.github.io/tags/go/"},{"title":"hugo","uri":"https://wangtingkui.github.io/tags/hugo/"},{"title":"nas","uri":"https://wangtingkui.github.io/tags/nas/"},{"title":"oh-my-zsh","uri":"https://wangtingkui.github.io/tags/oh-my-zsh/"},{"title":"php","uri":"https://wangtingkui.github.io/tags/php/"},{"title":"unicode","uri":"https://wangtingkui.github.io/tags/unicode/"},{"title":"utf-8","uri":"https://wangtingkui.github.io/tags/utf-8/"},{"title":"vmware","uri":"https://wangtingkui.github.io/tags/vmware/"},{"title":"vscode","uri":"https://wangtingkui.github.io/tags/vscode/"},{"title":"zsh","uri":"https://wangtingkui.github.io/tags/zsh/"},{"title":"字符编码","uri":"https://wangtingkui.github.io/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"},{"title":"源码分析","uri":"https://wangtingkui.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}]}