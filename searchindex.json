{"categories":[{"title":"go基础","uri":"https://wangtingkui.github.io/categories/go%E5%9F%BA%E7%A1%80/"},{"title":"使用hugo搭建个人网站","uri":"https://wangtingkui.github.io/categories/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/"}],"posts":[{"content":" 之前写php，使用phpbrew来进行php的版本管理，非常方便，同样的，go也有自己的多版本管理工具gvm，这篇文章就记录下如何在mac下使用gvm进行go的多版本管理\ngvm的信息可以参考：https://github.com/moovweb/gvm\n环境信息  macOS 10.15.2 brew 2.1.16  安装gvm bash \u0026lt; \u0026lt;(curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer)  下载好之后，需要修改下个人配置文件，使gvm相关命令生效，如果用的是bash，则修改~/.bashrc，如果习惯用zsh，那就修改~/.zshrc，以此类推\n[[ -s \u0026quot;$HOME/.gvm/scripts/gvm\u0026quot; ]] \u0026amp;\u0026amp; source \u0026quot;$HOME/.gvm/scripts/gvm\u0026quot;  修改之后，重开一会会话或者直接source ~/.zshrc（我用的是zsh）让刚才的修改生效。执行一下看下效果\n╰─$ gvm version Go Version Manager v1.0.22 installed at /Users/wangtingkui/.gvm  可以看到，我装的是 1.0.22 的版本\n常用命令 # 查看gvm版本 gvm version # 查看所有可以安装的版本 gvm listall # 查看本地已经安装的版本 gvm list # 安装指定版本 gvm install go1.13.5 # 删除指定版本 gvm uninstall go1.13.5 # 临时切换版本 gvm use go1.13.5 # 切换版本并指定为默认版本 gvm use go1.13.5 --default  使用 当我们使用gvm use \u0026lt;version\u0026gt;切换版本的时候，可以使用go env GOPATH看下，可以发现随着我们切换版本，GOPATH的路径也在变换，这样就不用害怕不同版本GOPATH下的内容冲突了\n","id":0,"section":"posts","summary":"之前写php，使用phpbrew来进行php的版本管理，非常方便，同样的，go也有自己的多版本管理工具gvm，这篇文章就记录下如何在mac下","tags":["go"],"title":"go多版本管理","uri":"https://wangtingkui.github.io/2019/12/go-multi-version-manage/","year":"2019"},{"content":" 上一篇文章中简单介绍了如何使用cobra框架，这篇文章让我们来看下cobra的源码，本文基于的cobra版本是v0.0.5\n首先需要了解的是，在cobra中，所有的命令会组成一个树的结构，必然有一个根命令，我们应用的每次执行，都是从这个根命令开始的，官方文档也说过，基于cobra的应用的main包中的代码是很简单的，几乎没有额外的操作，仅有的操作其实就是执行我们的根命令。所以自然而然的，我们的代码分析之旅也是从根命令的执行开始的。\n为了有个直观的感受，我简单生成了一个基于cobra的应用。这个应用有一个根命令和一个test1的子命令，项目结构如下：\n╰─$ tree . . ├── LICENSE ├── cmd │ ├── root.go │ └── test1.go ├── go.mod ├── go.sum └── main.go 1 directory, 6 files  主线执行分析 所有的项目不可能都是简单的一条线到底，代码总会有很多分支，但我们阅读源码的时候精力和关注度总是有限的（不是有人说人在同一时间关注的点不能超过7个还是几个来着么），如果代码里面的每个分支都去看，每个函数的调用都进去瞅瞅，很快我们就会迷失在复杂的代码里面，忘了我们怎么看到的这行代码，所以本文去分析源码的时候，会优先挑一条主线，主要跟踪这条主线上的逻辑和调用，忽略其他支线。当然，也会有比较重要的其他支线，但是和当前的主线无关，会单开一个小节去阅读分析\ncobra主线自然是入口-找到目标命令-分析参数-执行这条路径啦~\n看下main.go文件中都有点啥\npackage main import \u0026quot;learnCobra/cmd\u0026quot; func main() { cmd.Execute() }  简洁的一比，直接进入cmd.Execute\nfunc Execute() { if err := rootCmd.Execute(); err != nil { fmt.Println(err) os.Exit(1) } }  可以看到，其实就是执行了根命令的Execute方法，这个方法才是我们的重头戏。当然，所谓的根命令只是从命令的组织形态上来说的，所有的命令都是cobra.Command的这个结构体，后面绝大多数的代码也都是对这个结构体的成员和方法的分析\nfunc (c *Command) Execute() error { _, err := c.ExecuteC() return err }  毫无波澜，直接进c.ExecuteC()，这里开始我会在源码里面写点注释了\nfunc (c *Command) ExecuteC() (cmd *Command, err error) { // Regardless of what command execute is called on, run on Root only // 前面说过，我们所有的命令构成了一棵树，每次执行都是从根命令开始执行的 // 如果我们手残在代码的某处直接执行了一个子命令，这个方法也会向上遍历到根，然后执行根命令的 if c.HasParent() { return c.Root().ExecuteC() } // windows hook // windows 系统的钩子，不用care if preExecHookFn != nil { preExecHookFn(c) } // initialize help as the last point possible to allow for user // overriding // 初始化默认的帮助命令，不是我们的主线，不care c.InitDefaultHelpCmd() args := c.args // Workaround FAIL with \u0026quot;go test -v\u0026quot; or \u0026quot;cobra.test -test.v\u0026quot;, see #155 // 如果没有设置过命令的调用参数，使用os.Args[1:]作为默认参数 if c.args == nil \u0026amp;\u0026amp; filepath.Base(os.Args[0]) != \u0026quot;cobra.test\u0026quot; { args = os.Args[1:] } // 找真正要执行的命令，并解析flag // cobra为我们提供了两种flag，一种叫 persistant flag， // 这种 flag 可以在子命令中也获取到 // 另外一种叫 local flag // 这种 flag 只会在指定命令中被解析 // 默认情况下，cobra 只会解析目标命令的 local flag，父命令中的local flag将会被忽略 // 可以将命令的 TraverseChildren 属性置为 true ，cobra 会在执行命令前解析所有命令 // 的 local flag var flags []string if c.TraverseChildren { cmd, flags, err = c.Traverse(args) } else { // 我们当然是挑软柿子捏，当然挑这条简单的路走 cmd, flags, err = c.Find(args) } if err != nil { // If found parse to a subcommand and then failed, talk about the subcommand if cmd != nil { c = cmd } if !c.SilenceErrors { c.Println(\u0026quot;Error:\u0026quot;, err.Error()) c.Printf(\u0026quot;Run '%v --help' for usage.\\n\u0026quot;, c.CommandPath()) } return c, err } // 记录这个命令被调用过了，和被调用的名字 cmd.commandCalledAs.called = true if cmd.commandCalledAs.name == \u0026quot;\u0026quot; { cmd.commandCalledAs.name = cmd.Name() } // 执行找到的命令 err = cmd.execute(flags) if err != nil { // Always show help if requested, even if SilenceErrors is in // effect if err == flag.ErrHelp { cmd.HelpFunc()(cmd, args) return cmd, nil } // If root command has SilentErrors flagged, // all subcommands should respect it if !cmd.SilenceErrors \u0026amp;\u0026amp; !c.SilenceErrors { c.Println(\u0026quot;Error:\u0026quot;, err.Error()) } // If root command has SilentUsage flagged, // all subcommands should respect it if !cmd.SilenceUsage \u0026amp;\u0026amp; !c.SilenceUsage { c.Println(cmd.UsageString()) } } return cmd, err }  这里就有两个比较重要的方法了，c.Find和cmd.execute，我们先来看下怎么找到的目的命令\nfunc (c *Command) Find(args []string) (*Command, []string, error) { // 声明了一个函数类型的变量 var innerfind func(*Command, []string) (*Command, []string) // 定义了这个函数 innerfind = func(c *Command, innerArgs []string) (*Command, []string) { // 去掉 flag， 剩下的就是参数 argsWOflags := stripFlags(innerArgs, c) if len(argsWOflags) == 0 { return c, innerArgs } // 参数的第一个就是要执行的命令 nextSubCmd := argsWOflags[0] // 在子命令中去找有没有匹配 nextSubCmd 的子命令 cmd := c.findNext(nextSubCmd) if cmd != nil { // 递归的判断有没有匹配的子命令了 return innerfind(cmd, argsMinusFirstX(innerArgs, nextSubCmd)) } return c, innerArgs } // 调用了上面定义的那个函数，我擦，我也不知道作者为什么这样写 // 怕了怕了。。。先跳上去看逻辑吧 commandFound, a := innerfind(c, args) if commandFound.Args == nil { return commandFound, a, legacyArgs(commandFound, stripFlags(a, commandFound)) } return commandFound, a, nil }  然后我们再来看看cmd.execute\nfunc (c *Command) execute(a []string) (err error) { // 如果命令是个nil，那还执行个蛋 if c == nil { return fmt.Errorf(\u0026quot;Called Execute() on a nil Command\u0026quot;) } // 通过 Deprecated 这个属性判断这个命令是否将要被废弃 if len(c.Deprecated) \u0026gt; 0 { c.Printf(\u0026quot;Command %q is deprecated, %s\\n\u0026quot;, c.Name(), c.Deprecated) } // initialize help and version flag at the last point possible to allow for user // overriding // 添加默认的帮助flag和版本flag c.InitDefaultHelpFlag() c.InitDefaultVersionFlag() // 解析flag err = c.ParseFlags(a) if err != nil { return c.FlagErrorFunc()(c, err) } // If help is called, regardless of other flags, return we want help. // Also say we need help if the command isn't runnable. // 如果使用了帮助flag，忽略其他的flag helpVal, err := c.Flags().GetBool(\u0026quot;help\u0026quot;) if err != nil { // should be impossible to get here as we always declare a help // flag in InitDefaultHelpFlag() c.Println(\u0026quot;\\\u0026quot;help\\\u0026quot; flag declared as non-bool. Please correct your code\u0026quot;) return err } // 如果指定了帮助flag，返回一个帮助类型错误，上层会处理，调用命令的 HelpFunc if helpVal { return flag.ErrHelp } // for back-compat, only add version flag behavior if version is defined // 如果设置了Version属性，并且传递了 version flag，输出版本信息 if c.Version != \u0026quot;\u0026quot; { versionVal, err := c.Flags().GetBool(\u0026quot;version\u0026quot;) if err != nil { c.Println(\u0026quot;\\\u0026quot;version\\\u0026quot; flag declared as non-bool. Please correct your code\u0026quot;) return err } if versionVal { err := tmpl(c.OutOrStdout(), c.VersionTemplate(), c) if err != nil { c.Println(err) } return err } } // 判断是否可运行（也就是是否设置了命令的 Run 或者 RunE 属性） if !c.Runnable() { return flag.ErrHelp } // 执行准备，其实就是执行通过cobra.OnInitialize注册的初始化方法 c.preRun() // 获取所有flag之外的参数 argWoFlags := c.Flags().Args() if c.DisableFlagParsing { // 如果设置了 DisableFlagParsing 为 false // 也就是不解析 flag，把所有的参数当做命令的参数 argWoFlags = a } // 通过命令的 Args 属性设置的方法验证我们的参数 if err := c.ValidateArgs(argWoFlags); err != nil { return err } // PersistentPreRun 钩子函数 for p := c; p != nil; p = p.Parent() { if p.PersistentPreRunE != nil { if err := p.PersistentPreRunE(c, argWoFlags); err != nil { return err } break } else if p.PersistentPreRun != nil { p.PersistentPreRun(c, argWoFlags) break } } // PreRun 钩子函数 if c.PreRunE != nil { if err := c.PreRunE(c, argWoFlags); err != nil { return err } } else if c.PreRun != nil { c.PreRun(c, argWoFlags) } // 验证所有必要的flag if err := c.validateRequiredFlags(); err != nil { return err } // 执行自定义逻辑函数 if c.RunE != nil { if err := c.RunE(c, argWoFlags); err != nil { return err } } else { c.Run(c, argWoFlags) } // PostRun 钩子 if c.PostRunE != nil { if err := c.PostRunE(c, argWoFlags); err != nil { return err } } else if c.PostRun != nil { c.PostRun(c, argWoFlags) } // PersistentPostRun 钩子 for p := c; p != nil; p = p.Parent() { if p.PersistentPostRunE != nil { if err := p.PersistentPostRunE(c, argWoFlags); err != nil { return err } break } else if p.PersistentPostRun != nil { p.PersistentPostRun(c, argWoFlags) break } } return nil }  到此，大概的命令执行流程我们就分析完了。可以发现，这次的分析过程，我们并没有预先把cobra.Command结构里面的成员先看一遍，因为里面的成员实在是太太太多了，简单看一遍几乎是秒忘，所以对于这种成员非常多的结构体，建议直接跟流程，看到用什么成员，再去结构里看这个成员的说明。\n以上就是我们的整个分析过程了，如果有空，之后会补充一些重要的支线逻辑\n","id":1,"section":"posts","summary":"上一篇文章中简单介绍了如何使用cobra框架，这篇文章让我们来看下cobra的源码，本文基于的cobra版本是v0.0.5 首先需要了解的是，","tags":["go","cobra","源码分析"],"title":"go cli 应用框架cobra（二）- 源码分析","uri":"https://wangtingkui.github.io/2019/12/cobra-source-code-analysis/","year":"2019"},{"content":" hugo 是一个静态网页生成器，关于它的使用就不再多说，可以参考之前写过的使用hugo搭建个人站点系列文章。本系列主要是分析下 hugo 的源码，看下其他人是如何实现一个大型的 cli 应用\n第一篇文章从 hugo version 命令出发，简单了解下 hugo 应用的整体流程和代码结构，为后续比较复杂的命令分析做准备\n本系列文章都是基于 hugo 0.57.2 版本叙述的\n命令简介 version 命令的作用数输出当前 hugo 的版本，基本上所有的 cli 应用都会有这样的命令\n一个 hugo version 的输出：\n╰─$ hugo version Hugo Static Site Generator v0.57.2-A849CB2D darwin/amd64 BuildDate: 2019-08-17T17:53:28Z  源码分析 hugo是基于 cobra 这个命令行应用框架做的，如果能了解下cobra的基本使用会对我们的源码分析过程有比较大的帮助，关于 cobra，可以参考之前的两篇文章\n go cli 应用框架cobra（一）- 简介 go cli 应用框架cobra（二）- 源码分析  为了使我们的分析过程比较轻松，先来看下在 hugo version 这条主线中，会涉及到哪些比较主要的结构体\n baseCmd\n type baseCmd struct { cmd *cobra.Command } func (c *baseCmd) getCommand() *cobra.Command { return c.cmd } func (c *baseCmd) flagsToConfig(cfg config.Provider) { initializeFlags(c.cmd, cfg) }  前面我们也提到过，hugo 是基于 cobra 框架开发的，baseCmd 其实就是对 cobra 的 cobra.Command 的简单封装\n commandsBuilder\n type commandsBuilder struct { hugoBuilderCommon commands []cmder }  这是一个命令的构建器，是它将我们的version,new,config,check\u0026hellip; 等命令打包起来放在一个命令的子命令中，从而使我们方便的使用，其实就是用来生成我们的根命令\n hugoCmd\n type hugoCmd struct { *baseBuilderCmd // Need to get the sites once built. c *commandeer }  上面提到了 commandsBuilder 将命令打包，其实就是新建了一个 hugoCmd，将我们的子命令都放到这个命令下，可以认为 hugoCmd 就是我们的 hugo 这个根命令\n了解了上面几个基本的结构体，下面就让我们进入源码分析之旅吧，首先看下 main.go 入口文件：\nfunc main() { resp := commands.Execute(os.Args[1:]) if resp.Err != nil { if resp.IsUserError() { resp.Cmd.Println(\u0026quot;\u0026quot;) resp.Cmd.Println(resp.Cmd.UsageString()) } os.Exit(-1) } }  commands.Execute\n// Execute adds all child commands to the root command HugoCmd and sets flags appropriately. // The args are usually filled with os.Args[1:]. func Execute(args []string) Response { // 通过commandsBuilder生成hugoCmd，这个比较简单，就不深入看了 hugoCmd := newCommandsBuilder().addAll().build() // 获取原始的 cobra.Command cmd := hugoCmd.getCommand() // 将os.Args[1:] 设置为根命令的参数 cmd.SetArgs(args) // 执行命令，这里执行的cobra的源码，有兴趣的可以看一下，返回的是真正的哪个命令被执行以及一个error c, err := cmd.ExecuteC() var resp Response if c == cmd \u0026amp;\u0026amp; hugoCmd.c != nil { // Root command executed resp.Result = hugoCmd.c.hugo() } if err == nil { errCount := int(loggers.GlobalErrorCounter.Count()) if errCount \u0026gt; 0 { err = fmt.Errorf(\u0026quot;logged %d errors\u0026quot;, errCount) } else if resp.Result != nil { errCount = resp.Result.NumLogErrors() if errCount \u0026gt; 0 { err = fmt.Errorf(\u0026quot;logged %d errors\u0026quot;, errCount) } } } resp.Err = err resp.Cmd = c return resp }  ","id":2,"section":"posts","summary":"hugo 是一个静态网页生成器，关于它的使用就不再多说，可以参考之前写过的使用hugo搭建个人站点系列文章。本系列主要是分析下 hugo 的源码，看下其他人是","tags":null,"title":"hugo源码分析（一）- version","uri":"https://wangtingkui.github.io/2019/12/hugo-source-code-analysis-version/","year":"2019"},{"content":"hugo 内置了强大且支持自定义的分类系统，比如标签、类别、系列等，可以通过配置开启这些分类系统\n在config.toml中配置：\n[taxonomies] tag = \u0026quot;tags\u0026quot; category = \u0026quot;categories\u0026quot; seris = \u0026quot;series\u0026quot;  开启之后，只需要在文章的Front Matter对应的属性中，添加想要划分到的分类即可\n--- title: \u0026quot;php入门\u0026quot; date: 2019-10-10 tags: [\u0026quot;php\u0026quot;] categories: [\u0026quot;php\u0026quot;] series: [\u0026quot;php入门系列\u0026quot;]  ","id":3,"section":"posts","summary":"hugo 内置了强大且支持自定义的分类系统，比如标签、类别、系列等，可以通过配置开启这些分类系统 在config.toml中配置： [taxonomies] tag = \u0026quot;tags\u0026quot; category = \u0026quot;categories\u0026quot; seris = \u0026quot;series\u0026quot;","tags":["go"],"title":"使用hugo搭建个人网站（六）- 给你的文章分类","uri":"https://wangtingkui.github.io/2019/12/hugo-categorize-your-artical/","year":"2019"},{"content":"默认情况下，站点文章的 url 和我们 content 目录下的文件结构是一一对应的，比如有 content/posts/test.md 这篇文章，当我们发布之后，在站点访问的 url 就是 \u0026lt;domian\u0026gt;/posts/test，如果我们不想要这种形式，可以通过配置来改变默认的行为\n在使用配置之前，先让我们了解下 hugo 生成的 url 规则\n知道了每个段的含义，我们就可以使用hugo提供给我们的配置项来进行url的自定义\n可以在config.toml文件中的[permalinks]配置指定url的格式，比如\n[permalinks] post = \u0026quot;/:year/:month/:title/\u0026quot;  所有可用的属性如下\n:month :monthname :day :weekday :weekdayname :yearday :section :title :slug :filename  ","id":4,"section":"posts","summary":"默认情况下，站点文章的 url 和我们 content 目录下的文件结构是一一对应的，比如有 content/posts/test.md 这篇文章，当我们发布之后，在站点访问的 url 就是 \u0026lt;domian\u0026gt","tags":["go"],"title":"使用hugo搭建个人网站（五）- 定制你文章的url","uri":"https://wangtingkui.github.io/2019/12/hugo-custom-your-url/","year":"2019"},{"content":"加入我们要寻找content/posts下文章的模板\n当我们未在Front Matter中指定type和layout属性的时候，hugo默认的模板查找顺序是：\n\u0026lt;project_path\u0026gt;/layouts/UNSPECIFIED/UNSPECIFIED.html \u0026lt;project_path\u0026gt;/layouts/posts/UNSPECIFIED.html \u0026lt;project_path\u0026gt;/layouts/UNSPECIFIED/single.html \u0026lt;project_path\u0026gt;/layouts/posts/single.html \u0026lt;project_path\u0026gt;/layouts/_default/single.html \u0026lt;project_path\u0026gt;/themes/\u0026lt;THEME\u0026gt;/layouts/UNSPECIFIED/UNSPECIFIED.html \u0026lt;project_path\u0026gt;/themes/\u0026lt;THEME\u0026gt;/layouts/posts/UNSPECIFIED.html \u0026lt;project_path\u0026gt;/themes/\u0026lt;THEME\u0026gt;/layouts/UNSPECIFIED/single.html \u0026lt;project_path\u0026gt;/themes/\u0026lt;THEME\u0026gt;/layouts/posts/single.html \u0026lt;project_path\u0026gt;/themes/\u0026lt;THEME\u0026gt;/layouts/_default/single.html  当指定了type和layout属性的时候，查找顺序是：\n\u0026lt;project_path\u0026gt;/layouts/review/reviewarticle.html \u0026lt;project_path\u0026gt;/layouts/posts/reviewarticle.html \u0026lt;project_path\u0026gt;/layouts/review/single.html \u0026lt;project_path\u0026gt;/layouts/posts/single.html \u0026lt;project_path\u0026gt;/layouts/_default/single.html \u0026lt;project_path\u0026gt;/themes/\u0026lt;THEME\u0026gt;/layouts/review/reviewarticle.html \u0026lt;project_path\u0026gt;/themes/\u0026lt;THEME\u0026gt;/layouts/posts/reviewarticle.html \u0026lt;project_path\u0026gt;/themes/\u0026lt;THEME\u0026gt;/layouts/review/single.html \u0026lt;project_path\u0026gt;/themes/\u0026lt;THEME\u0026gt;/layouts/posts/single.html \u0026lt;project_path\u0026gt;/themes/\u0026lt;THEME\u0026gt;/layouts/_default/single.html  ","id":5,"section":"posts","summary":"加入我们要寻找content/posts下文章的模板 当我们未在Front Matter中指定type和layout属性的时候，hugo默认的模","tags":["go"],"title":"使用hugo搭建个人网站（五）- 模板选择顺序","uri":"https://wangtingkui.github.io/2019/12/hugo-template-order/","year":"2019"},{"content":"Front Matter 是扉页，前页的意思，顾名思义，他出现在我们文章的最前面，用来设定一些文章的元信息，比如是否是草稿，写作时间，文章所属的标签等等。\nFront Matter 同样支持很多数据格式YAML,JSON,TOML，可以通过Front Matter的前导符（包裹Front Matter的定界符）来告诉hugo我们使用的是什么配置语言\nFront Matter支持的标准配置有很多，但是只有两个属性是必须的，那就是title和date，代表了文章的标题和写作时间\n下面是hugo默认支持的常用Front Matter属性：\ntitle: \u0026quot;文章标题\u0026quot; date: 2012-12-12 description: \u0026quot;文章描述信息\u0026quot; tags: [\u0026quot;标签1\u0026quot;, \u0026quot;标签2\u0026quot;] categories: [\u0026quot;分类1\u0026quot;, \u0026quot;分类2\u0026quot;] keywords: [\u0026quot;关键字1\u0026quot;, \u0026quot;关键字2\u0026quot;] lastmod: 2015-10-10 isCJKLanguage: true # 是否是CJK语言 draft: true # 是否是草稿 expiryDate: 2020-10-10 # 文章过期时间 publishDate: 2020-10-10 # 文章发布时间 weight: 40 # 文章排序权重 # 使用这两个参数会重置permalink，默认使用文件名 url: slug: # 文章地址的别名 aliases: - /posts/hxxxx - xxxx # type 和 layout 将会改变 hugo 寻找文章模板的顺序 type: review layout: reviewartical  ","id":6,"section":"posts","summary":"Front Matter 是扉页，前页的意思，顾名思义，他出现在我们文章的最前面，用来设定一些文章的元信息，比如是否是草稿，写作时间，文章所属的标签等等。 Front Matter 同样","tags":["go"],"title":"使用hugo搭建个人网站（四）- Front Matter 配置详解","uri":"https://wangtingkui.github.io/2019/12/hugo-front-matter/","year":"2019"},{"content":" 引用站点内其他文章 很多情况下，我们会产出所谓的系列文章，这时候，我们可能会想在系列文章中加上同系列其他文章的引用链接，方便读者阅读，hugo 帮我们实现了这种功能，只需要在文章中使用 {{\u0026lt; ref \u0026quot;posts/my_post.md\u0026quot; \u0026gt;}}或者{{\u0026lt; relref \u0026quot;posts/my_post.md\u0026quot; \u0026gt;}}即可，前者是相对链接，后者是绝对链接\n一些例子：\n{{\u0026lt; ref \u0026quot;blog/post.md\u0026quot; \u0026gt;}} =\u0026gt; https://example.com/blog/post/ {{\u0026lt; ref \u0026quot;post.md#tldr\u0026quot; \u0026gt;}} =\u0026gt; https://example.com/blog/post/#tldr:caffebad {{\u0026lt; relref \u0026quot;post.md\u0026quot; \u0026gt;}} =\u0026gt; /blog/post/ {{\u0026lt; relref \u0026quot;blog/post.md#tldr\u0026quot; \u0026gt;}} =\u0026gt; /blog/post/#tldr:caffebad {{\u0026lt; ref \u0026quot;#tldr\u0026quot; \u0026gt;}} =\u0026gt; #tldr:badcaffe {{\u0026lt; relref \u0026quot;#tldr\u0026quot; \u0026gt;}} =\u0026gt; #tldr:badcaffe  如果是不是需要引用，而仅仅是需要展示{{\u0026lt; ref \u0026quot;blog/post.md\u0026quot; \u0026gt;}}这样的文本，需要在标签内加上/* */这样的注释，比如{{\u0026lt;/* ref \u0026quot;blog/post.md\u0026quot; */\u0026gt;}}\n","id":7,"section":"posts","summary":"引用站点内其他文章 很多情况下，我们会产出所谓的系列文章，这时候，我们可能会想在系列文章中加上同系列其他文章的引用链接，方便读者阅读，hugo","tags":["go"],"title":"使用hugo搭建个人网站（三）- 其他使用技巧","uri":"https://wangtingkui.github.io/2019/12/hugo-other-skills/","year":"2019"},{"content":" flag 包是官方给我们提供的解析命令行选项的标准包，本文主要对其进行源码分析，如果仅仅只是需要学会简单的使用，可以参考Go标准库（flag）- 使用\n核心数据类型 首先还是来看下flag包中有哪些核心的类型，主要有两个接口和两个结构体\ninterface:\n// 抽象类型， 我们后续也是通过这个接口来扩展我们flag包支持的数据类型的 type Value interface { String() string Set(string) error } type Getter interface { Value Get() interface{} }  struct:\n// 代表一个命令行选项 type Flag struct { Name string // name as it appears on command line // 标签在命令行显示的名字 Usage string // help message // 帮助信息 Value Value // value as set // 标签的值 DefValue string // default value (as text); for usage message // 默认值（文本格式）；这也是一个用法的信息说明 } // 代表一个选项集合，其实可以认为就是在shell中敲入的命令被拆分解析之后就是FlagSet type FlagSet struct { // 当解析标签出现错误的时候，Usage就会被调用。这个字段是一个函数（不是一个方法），它可以指向 // 用户自己定义的错误处理函数。 Usage func() name string // 名字，一般默认是os.Args[0] parsed bool\t// 是否已经解析过了（是否调用过flag.Parse()） actual map[string]*Flag // 解析过得flag数组 formal map[string]*Flag // 注册的flag数组 args []string // 解析过后，剩余的non-flag参数 errorHandling ErrorHandling // 解析失败后的处理方式 output io.Writer // nil means stderr; use out() accessor }  源码分析 很多包在提供了底层类型的同时，为了方便我们使用，经常会在包内初始化一个默认对象，然后在开放一些导出函数供我们使用，flag 包也是这样的，标准库的实现者在包内初始化了一个名为CommandLine的FlagSet类型对象，我们经常使用的flag.String(),flag.BoolVal()等方法其实就是对这个对象的操作\n接下来就让我们追踪下最常用的flag.String的调用，看下flag包的内部实现逻辑吧\n注册 flag.String\n// 可以看到，flag.String 其实是对 CommandLine 对象 String 方法的包装，和我们刚才提到的是吻合的 func String(name string, value string, usage string) *string { return CommandLine.String(name, value, usage) }  CommandLine.String\n// 帮我们创建了一个string类型的指针，返回给后续使用， // 这里也可以看到，Xxx()这种方法比XxxVar()的方法只是多了一步帮我们创建变量的过程，其实更底层是一样的 func (f *FlagSet) String(name string, value string, usage string) *string { p := new(string) f.StringVar(p, name, value, usage) return p }  f.StringVar\n// FlagSet.StringVar 将我们的string类型的指针包装成了 stringValue 这个实现了 Value 接口的类型 func (f *FlagSet) StringVar(p *string, name string, value string, usage string) { f.Var(newStringValue(value, p), name, usage) }  f.Var\nfunc (f *FlagSet) Var(value Value, name string, usage string) { // 创建一个Flag对象 flag := \u0026amp;Flag{name, usage, value, value.String()} // 检测是否已经注册过同名的flag _, alreadythere := f.formal[name] if alreadythere { var msg string if f.name == \u0026quot;\u0026quot; { msg = fmt.Sprintf(\u0026quot;flag redefined: %s\u0026quot;, name) } else { msg = fmt.Sprintf(\u0026quot;%s flag redefined: %s\u0026quot;, f.name, name) } fmt.Fprintln(f.Output(), msg) panic(msg) // Happens only if flags are declared with identical names } // 初始化formal if f.formal == nil { f.formal = make(map[string]*Flag) } // 放到注册的标记集合中 f.formal[name] = flag }  解析 执行到这里，我们的选项注册工作已经完成了，下一步就是命令行参数的解析，从而把用户真正的输入拿到，执行解析，我们调用的方法是flag.Parse\nflag.Parse\n// 其实是对FlagSet.Parse的封装 // 同时也看到，flag包对参数的解析默认是从命令行输入的第二个字符串开始的 func Parse() { // Ignore errors; CommandLine is set for ExitOnError. CommandLine.Parse(os.Args[1:]) }  CommandLine.Parse\nfunc (f *FlagSet) Parse(arguments []string) error { // 将解析标记置为true，标记这个FlagSet已经被解析过了 f.parsed = true // 将所有参数放到盛放non-flag参数的容器中 // 后续解析过程会一个一个参数从这个容器中往外拿，直到解析结束 f.args = arguments for { // 逐个解析参数 seen, err := f.parseOne() if seen { continue } // 解析完成，退出循环，f.parseOne 返回 false,nil 的时候 if err == nil { break } // 如果有error发生，根据设置定的error处理方式处理error switch f.errorHandling { case ContinueOnError: return err case ExitOnError: os.Exit(2) case PanicOnError: panic(err) } } return nil }  f.parseOne\n// 这个方法是最主要的一个方法，他解析我们的参数 // 这个方法是被循环调用的，决定解析是否终止的条件也在这个方法中，在源码中我会标记出来 func (f *FlagSet) parseOne() (bool, error) { // 没有参数，不需要解析 if len(f.args) == 0 { return false, nil } s := f.args[0] // 结束条件1：字符串长度小于零或者不是以 - 字符开头的 if len(s) \u0026lt; 2 || s[0] != '-' { return false, nil } numMinuses := 1 if s[1] == '-' { numMinuses++ // 结束条件2：字符串是以 -- 开头的 if len(s) == 2 { // \u0026quot;--\u0026quot; terminates the flags f.args = f.args[1:] return false, nil } } // 取出真正的字符值（去掉前缀 - 或者 -- ） name := s[numMinuses:] // 字符串合法检测 if len(name) == 0 || name[0] == '-' || name[0] == '=' { return false, f.failf(\u0026quot;bad flag syntax: %s\u0026quot;, s) } // it's a flag. does it have an argument? f.args = f.args[1:] hasValue := false value := \u0026quot;\u0026quot; // 通过等号判断是不是 \u0026quot;name=value\u0026quot; 这种格式类型的flag for i := 1; i \u0026lt; len(name); i++ { // equals cannot be first if name[i] == '=' { value = name[i+1:] hasValue = true name = name[0:i] break } } m := f.formal // 判断是否注册过指定名称的flag flag, alreadythere := m[name] // BUG if !alreadythere { // 默认支持解析 help 和 h 选项 if name == \u0026quot;help\u0026quot; || name == \u0026quot;h\u0026quot; { // special case for nice help message. f.usage() return false, ErrHelp } return false, f.failf(\u0026quot;flag provided but not defined: -%s\u0026quot;, name) } // bool类型的flag支持 -flag 形式的写法，传了标记就是true，不传就依赖默认值 if fv, ok := flag.Value.(boolFlag); ok \u0026amp;\u0026amp; fv.IsBoolFlag() { // special case: doesn't need an arg if hasValue { if err := fv.Set(value); err != nil { return false, f.failf(\u0026quot;invalid boolean value %q for -%s: %v\u0026quot;, value, name, err) } } else { if err := fv.Set(\u0026quot;true\u0026quot;); err != nil { return false, f.failf(\u0026quot;invalid boolean flag %s: %v\u0026quot;, name, err) } } } else { // It must have a value, which might be the next argument. if !hasValue \u0026amp;\u0026amp; len(f.args) \u0026gt; 0 { // value is the next arg hasValue = true value, f.args = f.args[0], f.args[1:] } if !hasValue { return false, f.failf(\u0026quot;flag needs an argument: -%s\u0026quot;, name) } if err := flag.Value.Set(value); err != nil { return false, f.failf(\u0026quot;invalid value %q for flag -%s: %v\u0026quot;, value, name, err) } } // 初始化f.actual if f.actual == nil { f.actual = make(map[string]*Flag) } // 放在解析后的容器里面 f.actual[name] = flag return true, nil }  ","id":8,"section":"posts","summary":"flag 包是官方给我们提供的解析命令行选项的标准包，本文主要对其进行源码分析，如果仅仅只是需要学会简单的使用，可以参考Go标准库（flag）- 使用","tags":null,"title":"Go标准库（flag）- 源码分析","uri":"https://wangtingkui.github.io/2019/12/go-std-lib-flag-source-code/","year":"2019"},{"content":" 本文所讨论内容基于的go版本：go1.13\n在我们编写命令行程序的时候，解析命令行的参数是非常常见的一种需求，Go标准库中的flag包为我们提供了解析命令行参数的功能\n要使用flag包，主要有3个步骤：定义flag、解析flag、使用flag\n定义flag flag包为我们提供了两种定义flag的方式，flag.Xxx()方式和flag.XxxVar()方式,其中Xxx可以是Int,String等类型，其中第一种会返回对应类型的指针，第二种则是将flag绑定到一个变量上\n// 方式1 var config *string = flag.String(\u0026quot;config\u0026quot;. \u0026quot;path/to/config\u0026quot;, \u0026quot;配置文件路径\u0026quot;) // 方式2 var intval int flag.IntVal(\u0026amp;intval, \u0026quot;intval\u0026quot;, 1, \u0026quot;a intger value\u0026quot;)  除了标准库中提供的基础数据类型的解析，如果我们需要解析自定义的类型，可以使用flag.Val()方法，只要绑定的类型实现了flag.Value接口即可\n解析flag 当定义完了所有的flag之后，我们可以调用flag.Parse()方法解析命令行参数\n使用flag 当使用命令行传递flag的时候，有以下三种语法格式（虽说官方只写了一个-，但其实当flag是bool类型的时候--也是支持的，但最好还是按照官方的来）\n-flag // 只支持 bool 类型 -flag value // 只支持非 bool 类型，因为比如有`cmd -x false`这种格式，不能确定false到底是flag的值还是一个参数 -flag=value  在命令行传递参数时，如果是int类型，可以传递十进制、十六进制、八进制或者是负数；如果是bool类型，可以使用1,0,t,g,true,false,TRUE,FALSE,True,Flase；如果是duration，可以接受任何time.ParseDuration可以解析的类型\nnon-flag 参数 在上面的说明中我们知道，传递参数的时候有固定格式，那不符合这些格式的参数就是non-flag参数\n在代码中，我们可以通过下面的这些方法来获取和使用non-flag参数\nflag.Arg(i int) // 获取第i个non-flag参数 flag.Args() // 获取所有的non-flag参数 flag.NArg() // 获取non-flag参数的个数  一个例子 package main import ( \u0026quot;flag\u0026quot; \u0026quot;fmt\u0026quot; ) func main() { var ( s = flag.String(\u0026quot;s\u0026quot;, \u0026quot;defaut string value\u0026quot;, \u0026quot;flag of type string\u0026quot;) i = flag.Int(\u0026quot;i\u0026quot;, 0, \u0026quot;flag of type int\u0026quot;) ) flag.Parse() output := fmt.Sprintf(`value of s flag:%s value of i flag:%d count of non-flag:%d item of non-flag:%v`, *s, *i, flag.NArg(), flag.Args()) fmt.Println(output) }  查看下输出：\n╰─$ ./flag -i 10 -s abc haha hehe value of s flag:abc value of i flag:10 count of non-flag:2 item of non-flag:[haha hehe]  ","id":9,"section":"posts","summary":"本文所讨论内容基于的go版本：go1.13 在我们编写命令行程序的时候，解析命令行的参数是非常常见的一种需求，Go标准库中的flag包为我们提","tags":null,"title":"Go标准库（flag）- 使用","uri":"https://wangtingkui.github.io/2019/12/go-std-lib-flag/","year":"2019"},{"content":" 上一篇文章已经让我们简单了解了如何使用hugo，但是我们使用hugo的最终目的还是依靠它去搭建一个我们的个人站点，hugo能解决的是静态站点的生成，那么剩下的一个问题就是如何部署我们生成的站点，供其他人访问\n这篇文章帮助我们了解如何使用github pages的功能来部署我们的个人站点\n使用 github pages 的好处  完全免费 不需要自己购买服务器 不需要自己运行维护 可以方便的使用https  github pages 的限制 当然github pages本身还是有一些限制的\n 网站大小不能超过1GB 网站不能发布的过于频繁（每小时不超过10个版本） 每个月流量上限为1000GB  但是作为个人博客来说，这些限制几乎对我们没什么影响\n如何使用 github pages github pages 官方文档\n 申请一个github账号，每个github账号可以有一个个人站点和多个项目站点（这个以后有机会在单独写文章说一下） 创建一个\u0026lt;username\u0026gt;.github.io的仓库 当我们执行hugo命令去生成我们的静态站点的文件时，默认会放在当前目录的public目录（当然你也可以通过配置hugo从而指定目录），所以我们直接把创建好的仓库拉取到项目下的public目录即可git clone git@github.com:wangtingkui/wangtingkui.github.io.git ./public 指定hugo命令生成站点文件 进入public文件夹，将生成的文件提交到git，然后推送到远端即可\ncd public git add . git commit -m \u0026quot;提交信息\u0026quot; git push -u origin master   推送之后，访问\u0026lt;username\u0026gt;.github.io你就会惊奇的发现你的个人站点已经可以访问了，如果访问的时候没有效果，也不要着急，那是github还在处理中，去休息一下，过段时间在访问就会生效啦~\n","id":10,"section":"posts","summary":"上一篇文章已经让我们简单了解了如何使用hugo，但是我们使用hugo的最终目的还是依靠它去搭建一个我们的个人站点，hugo能解决的是静态站点","tags":["go"],"title":"使用hugo搭建个人网站（二）- 使用 github pages 部署 hugo 生成的静态站点","uri":"https://wangtingkui.github.io/2019/12/hugo-with-github-pages/","year":"2019"},{"content":" 简介 cobra是一个go语言的命令行应用框架，他也是一个用来快速生成命令行应用的脚手架\n一些基础概念 cobra推崇的是The best applications will read like sentences when used. Users will know how to use the application because they will natively understand how to use it.也就是我们的应用应该做到自解释，让使用者可以很容易的上手，使用的时候就像是说话一样的简单和自然\n一个遵循这个理念的命令行应用模式是 APPNAME VERB NOUN -ADJECTIVE 或者换种表达方式 APPNAME COMMADN ARG --FLAG\n APPNAME是我们应用的名称 COMMAND是我们要执行的动作，一般是个动词 ARG是我们动作作用的对象，一般是个名词 --FLAG是用来调整我们动作的行为，一般是个形容词  一个例子：git clone URL --bare\n项目结构 我们可以按照自己的喜好去组织我们的项目代码，但是一般情况下，基于cobra的项目会有以下的项目结构\n╰─$ tree . ├── LICENSE ├── cmd │ └── root.go └── main.go 1 directory, 3 files  快速上手构建项目 上面也提到了，cobra 不仅仅是一个命令行框架，它也能辅助我们快速生成我们的项目文件，接下来就让我们使用 cobra 提供的脚手架帮助我们生成基于 cobra 框架的命令行应用（如果还没有安装cobra脚手架，可以进入github.com/spf13/cobra/cobra然后go install一下）\n# 创建项目 cobra init --pkg-name github.com/wangtingkui/testCobra ./testCobra # 创建完成之后，就可以看到我们上面那个默认的目录结构了 # 给我们的应用添加命令 cobra add serve # 添加 serve 命令 cobra add config # 添加 config 命令 cobra add create -p 'configCmd' # 给 config 命令添加 create 子命令，`-p`指定这个命令的父命令，这个没有什么逻辑校验，就是在新命令的文件中init方法里面添加`configCmd.AddCommand(createCmd)`这行代码而已  创建完成之后，再来看下最终生成的目录结构\n╰─$ tree . ├── LICENSE ├── cmd │ ├── config.go │ ├── create.go │ ├── root.go │ └── serve.go └── main.go 1 directory, 6 files  测试下我们的项目\n主应用\n╰─$ ./testCobra A longer description that spans multiple lines and likely contains examples and usage of using your application. For example: Cobra is a CLI library for Go that empowers applications. This application is a tool to generate the needed files to quickly create a Cobra application. Usage: testCobra [command] Available Commands: config A brief description of your command help Help about any command serve A brief description of your command Flags: --config string config file (default is $HOME/.testCobra.yaml) -h, --help help for testCobra -t, --toggle Help message for toggle Use \u0026quot;testCobra [command] --help\u0026quot; for more information about a command.  serve 命令\n╰─$ ./testCobra serve serve called  ","id":11,"section":"posts","summary":"简介 cobra是一个go语言的命令行应用框架，他也是一个用来快速生成命令行应用的脚手架 一些基础概念 cobra推崇的是The best applications will read like sentences when used. Users","tags":null,"title":"go cli 应用框架cobra（一）- 简介","uri":"https://wangtingkui.github.io/2019/12/cobra-introduction/","year":"2019"},{"content":" 作为一名coder，日常的开发工作中不可避免的会接触一些字符编码相关的东西，之前只是模模糊糊的了解一点，没有明确的，系统性的认知。一个最典型的例子就是当我们的代码遇到了乱码，这时候其他人总会告诉我们要使用utf-8编码就可以解决问题，但这背后蕴含的原理，却一直没有探索过，所以就查了一些资料，将查到的资料提炼汇总，有了这篇文章\n字符编码的发展历程 我们知道，所有的数据在计算机中都是用二进制串来表示的，那么人类世界的语言符号，想要在计算机中表示，就必须有对应的转换规则，这就是字符编码\nASCII 时期 上世纪60年代，美国制定了一套字符编码，它使用一个字节来对英语字符和二进制串进行映射，这就是ASCII码。\nASCII一共规定了128个字符，其中包含32个控制字符，由于ASCII只有128个字符，所以只占用了一个字节的7位，所以规定最前面的1位统一为0\n传统字符编码时期 由于不是所有国家的语言体系都是英文，比如中国使用的汉字，字符数量就远远超过了一个字符所能容纳的极限，所有随着计算机的普及，各个国家都提出了自己的字符编码方案，基本的策略就是使用更多的字节空间，兼容ASCII，然后用剩下的空间来编码其他的字符。比如中国的GB2312、BIG5等，但是这就导致了一个问题，各个国家都只是兼容了ASCII，然后编码了本国语言，对其他语言是不支持的，所以导致当时的计算机只能处理双语言环境，不支持多语言环境。\n假如遇到要在一个文本中同时出现中文、英文、阿拉伯文的时候，就无法进行编码处理了。\nunicode 时期 为了解决传统编码方式带来的问题，unicode出现了，下面就让我们详细看下unicode是如何解决上面的这些问题的\n现代编码模型 在探讨unicode是个什么东西之前，我们先来了解一下现代编码模型，因为要完美解决上面提到的编码问题，以及保证这套字符编码的可扩展性（因为到现在为止，还不断有更多的字符在加入到我们的语言体系之中），已经不能只是用简单规定几个字节，然后将字符和编码一一对应来处理了。\n现代编码模型将字符编码从底向上分为了几个层次：\n 抽象字符表（Abstract Character Repertoire）   就是这个编码系统所包含的所有抽象字符的集合，比如ASCII编码里面就有128个抽象字符。抽象字符表可以是封闭的，比如ASCII，不允许添加新的字符，也可以是开放的，比如unicode，可以添加新的字符进去。要注意的是，抽象字符表是一个集合，集合有一个最大的特点就是无序的。\n  编码字符集（Coded Character Set）   抽象字符表是抽象字符的集合，集合是无序的。无序的抽象字符表其实没什么卵用，因为我们只能判断一个字符在不在这个抽象字符表中，却无法方便的引用这个字符。为了更好的描述和操作字符，我们为抽象字符表中的每个抽象字符关联一个数字编号，这个数字编号叫做Code Point（译为码位），编码字符集就是为所有的字符都分配了码位的字符集。\n码位一般是非负整数，习惯上使用十六进制表示。码位的分配也不一定是连续的。\n最常见的编码字符集就是UCS（Universal Character Set），这也是unicode标准下使用的编码字符集\n- [0x0000,0xD7FF] 和 [0xE000,0x10FFFF] 这两个区间称为unicode标量值(unicode scala value) - [0xD800,0xDBFF] 称为 Hign-surrogate - [0xDC00,0xDFFF] 称为 Low-surrogate    字符编码表（Character Encoding Form）   当我们有了编码字符集之后，是不是所有的问题已经解决了呢，当然不是，上面提到过，字符集可以是开放的，所以理论上UCS需要的码位是无限的，但是就算是计算机中uint32，也只有4个字节，最多只能表示4294967295个码位，这样矛盾就出现了。解决这个矛盾的方案，就是字符编码表\n字符编码表是一个将Unicode标量值(Unicode scalar value)一一映射为码元序列(Code Unit Sequences)的映射。 之所以必须是一一映射，那是因为我们不光要编码，也要解码。 在Unicode中，指定了三种标准的字符编码表，UTF-8,UTF-16,UTF-32。分别将Unicode标量值映射为比特数为8、16、32的码元的序列。 即，UTF-8的码元为uint8, UTF-16的码元为uint16, UTF-32的码元为uint32。 当然也有一些非标准的CEF，如UCS-2,UCS-4，在此不多介绍。\n码元 Code unit: The minimal bit combination that can represent a unit of encoded text for processing or interchange. 码元是能用于处理或交换编码文本的最小比特组合。通常计算机处理字符的码元为一字节，即8bit。同时因为计算机中char其实是一种整形，而整形的计算往往以计算机的字长作为一个基础单元，通常来讲，也就是4字节。Unicode定义了三种不同的CEF，分别采用了1字节，2字节，4字节的码元，正好对应了计算机中最常见的三种整形长度。\n如何将一个无限大的整数，一一映射为指定字宽的码元序列。 这个问题可以通过变长编码来解决。 无论是UTF-8还是UTF-16，本质思想都是通过预留标记位来指示码元序列的长度。从而实现变长编码的。\n  字符编码方案（Character Encoding Schema）   简单说，字符编码方案CES等于字符编码表CEF加上字节序列化的方案。\n通过CEF，我们已经可以将字符转为码元(Code Unit)。无论是哪种UTF-X的码元，都可以找到计算机中与之对应的整形存放。那么现在我们能说存储处理交换字符这个问题解决了吗？ 还不行。 因为从码元落实到底层的存储，还有一些问题需要解决。 假设一个字符按照UTF16拆成了A，B两个码元，那实际存储的时候究竟应该把A放在前面呢还是B放在前面呢？而另一个程序又如何知道当前这份文件是按照什么样的端序存储码元的呢？ 无论是大端法与小端法的选择，还是用于决定编码字节序的标记，都是CES需要操心的方案。\n所以Unicode实际上定义了7种字符编码方案CES\n- UTF-8 - UTF-16LE - UTF-16BE - UTF-16 - UTF-32LE - UTF-32BE - UTF-32  UTF-8因为已经采用字节作为码元了，所以实际上是不存在字节序的问题。其他两种CES嘛，都有一个大端版本一个小端版本，还有一个随机应变大小端带BOM的版本\n当然，这里也出现一个问题，UTF-X可以同时指代字符编码表CEF或者字符编码方案CES。UTF-8问题还好，因为UTF-8的字节序列化方案太朴素了，以至于CES和CEF都没什么区别。但其他两种：UTF-16,UTF-32，就比较棘手了。当我们说UTF-16时，既可以指代UTF-16字符编码表，又可以指代UTF-16字符编码方案。所以当有人说“这个字符串是UTF-16编码的”时，鬼知道他到底说的到底是一个（UTF-16 encoding form的）码元序列还是(UTF-16 encoding schema 的)带BOM序列化好的一串字节流\n  传输编码语法（Transfer Encoding Syntax）   通过CES，我们已经可以将一个字符表示为一个字节序列。 但是有时候，字节序列表示还不够。比如在HTTP协议中，在URL里，一些字符是不允许出现的。这时候就需要再次对字节流进行编码。\n著名的Base64编码，就是把字节流映射成了一个由64个安全字符组成字符集所表示的字符流。从而使字节流能够安全地在Web中传输。\n 参考文章  http://vonng.com/blog/character-set/  ","id":12,"section":"posts","summary":"作为一名coder，日常的开发工作中不可避免的会接触一些字符编码相关的东西，之前只是模模糊糊的了解一点，没有明确的，系统性的认知。一个最典型","tags":["字符编码","unicode","utf-8"],"title":"详解字符编码","uri":"https://wangtingkui.github.io/2019/09/unicode/","year":"2019"},{"content":" 以blog为例，看看hugo是如何使用的\n创建一个网站项目 hugo new site blog， 执行这个命令后，会在当前目录下创建一个blog目录 ，这个目录就是我们的项目目录\n简单了解下目录的结构\n. ├── archetypes # 存储 .md 的模板文件 │ └── default.md ├── config.toml # 配置文件 ├── content # 存储网站所有的内容 ├── data # 存储数据文件供模板调用 ├── layouts # 存储 .html 模板 ├── static # 存储图片、css、js等静态文件，该目录下的文件会直接拷贝到 /public └── themes # 存储主题 6 directories, 2 files  快速体验 让我们快速体验下hugo的威力\nhugo创建出来的项目默认不带有任何主题，我们直接从github上随便搞一个，放到之前提到的themes文件夹下\ngit clone https://github.com/budparr/gohugo-theme-ananke.git ./themes/ananke\n然后在配置文件中配置应用这个主题\necho 'theme = \u0026quot;ananke\u0026quot;' \u0026gt;\u0026gt; config.toml\n接下来该正常的用markdown写作我们的文章了，使用如下命令新建一个文章\nhugo new post/my-first-post.md\n可以看到在content文件夹下多出了一个post文件夹，里面有一个my-fisrt-post.md的markdown文件，我们看下创建出来的这个文件里面的内容都有什么\n content/post/my-first-post.md 文件内容\n --- title: \u0026quot;My First Post\u0026quot; date: 2019-09-22T14:53:48+08:00 draft: true ---  这些默认生成的内容其实就是文章的一些元信息，比如文章的标题，创建的时间等等，里面的具体属性我们稍后再细讲。那这些内容是根据什么生成的呢，还记得我们上面给出的目录结构么，archetypes目录用来存放 md 文件的模板，让我们进去瞅瞅里面有啥，vim archetypes/default.md\n archetypes/default.md 文件内容\n --- title: \u0026quot;{{ replace .Name \u0026quot;-\u0026quot; \u0026quot; \u0026quot; | title }}\u0026quot; date: {{ .Date }} draft: true ---  看起来是不是和我们刚才生成的文件结构超像，其实那个文件就是依据这个模板来的\n我们来改动下刚才生成的文件，编辑一些自定义的内容\n content/post/my-first-post.md 文件内容\n --- title: \u0026quot;My First Post\u0026quot; date: 2019-09-22T14:53:48+08:00 draft: true --- ### 这是我的第一篇文章 内容就是用来测试的啦~  最重要的一步来了，生成我们的站点，hugo内置了一个server，方便我们在书写文章的过程中快速的预览到站点效果，只需要执行下面的命令即可\nhugo server -D\n其中-D选项是告诉hugo把草稿状态的文章也渲染出来，执行完之后，hugo就提示我们已经可以从http://localhost:1313去访问我们的站点了，赶紧去看一下，是不是很吊呢\n","id":13,"section":"posts","summary":"以blog为例，看看hugo是如何使用的 创建一个网站项目 hugo new site blog， 执行这个命令后，会在当前目录下创建一个blog目录 ，这个目录就是我们","tags":["go"],"title":"使用hugo搭建个人网站（一）- hugo使用入门","uri":"https://wangtingkui.github.io/2019/09/hugo-introduction/","year":"2019"}],"tags":[{"title":"cobra","uri":"https://wangtingkui.github.io/tags/cobra/"},{"title":"go","uri":"https://wangtingkui.github.io/tags/go/"},{"title":"unicode","uri":"https://wangtingkui.github.io/tags/unicode/"},{"title":"utf-8","uri":"https://wangtingkui.github.io/tags/utf-8/"},{"title":"字符编码","uri":"https://wangtingkui.github.io/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"},{"title":"源码分析","uri":"https://wangtingkui.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}]}